---
title: "An√°lisis de Series de Tiempo y Pron√≥sticos ARIMA"
subtitle: "Estudio Emp√≠rico sobre el Precio de Acciones del QQQ"
author: "Camilo"
date: "`r format(Sys.Date(), '%d de %B de %Y')`"
output:
  html_document:
    theme: darkly
    toc: false         
    toc_float: false   
---

<div id="custom-toc"></div>

```{=html}
<style type="text/css">

/* ========== PALETA DE COLORES CLARA - EST√âTICA PROFESIONAL Y DIN√ÅMICA ========== */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Poppins:wght@500;600;700&display=swap');

html, body {
  font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif !important;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
h1, h2, h3 {
  font-family: 'Poppins', 'Inter', sans-serif !important;
  letter-spacing: -0.02em;
}
:root {
  --bg-light: #ffffff;
  --bg-lighter: #f5f7fa;
  --text-dark: #1f2937;
  --text-medium: #4b5563;
  --text-gray: #94a3b8;
  --accent-primary: #00b894;
  --accent-secondary: #06b6d4;
  --accent-positive: #84cc16;
  --accent-negative: #e17055;
  --accent-soft: #3b82f6;
}

* {
  box-sizing: border-box !important;
  margin: 0;
  padding: 0;
}

html, body {
  background: var(--bg-light) !important;
  color: var(--text-dark) !important;
  font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
  line-height: 1.65 !important;
  overflow-x: hidden !important;
  min-height: 100vh !important;
}

div.container-fluid:first-of-type {
  width: auto !important;
  max-width: 100% !important;
  padding: 60px 80px !important;
}

#custom-toc {
  position: fixed;
  top: 60px;
  left: 0;
  width: 260px;
  height: 80vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  padding: 0;
  background: var(--bg-lighter);
  border-right: 2px solid var(--accent-secondary);
  border-radius: 0 10px 10px 0;
  box-shadow: 0 4px 20px rgba(0,0,0,0.15);
  z-index: 999;
}

#custom-toc h2 {
  position: relative;
  flex-shrink: 0;
  background: var(--bg-lighter);
  z-index: 10;
  padding: 10px 15px 15px 15px; 
  margin: 0;
  border-bottom: 2px solid rgba(0, 184, 148, 0.3);
  box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
}

#custom-toc ul {
  list-style: none !important;
  padding: 0px 10px 20px 10px !important; 
  margin: 0 !important;
  flex-grow: 1;
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: var(--accent-secondary) transparent;
}

#custom-toc li:first-child {
  margin-top: 2px !important;
}

#custom-toc li {
  margin: 8px 0 !important;
}

#custom-toc a {
  display: block;
  padding: 10px 14px;
  color: var(--text-medium) !important;
  text-decoration: none;
  border-radius: 8px;
  transition: all .2s ease;
}

#custom-toc a:hover {
  background: rgba(0,184,148,0.15);
  color: var(--accent-primary) !important;
  transform: translateX(5px);
  box-shadow: 0 4px 14px rgba(0,0,0,0.12);
}

#custom-toc a.active {
  background: var(--bg-light);
  color: var(--accent-primary) !important;
  border-left: 5px solid var(--accent-secondary);
  font-weight: 600;
  transform: translateX(4px);
}

#custom-toc::-webkit-scrollbar {
  width: 6px !important;
}

#custom-toc::-webkit-scrollbar-thumb {
  background: var(--accent-secondary) !important;
  border-radius: 10px !important;
}

#TOC {
  display: none !important;
}

.section.level1 {
  margin-bottom: 80px !important;
  padding: 50px !important;
  background: linear-gradient(180deg, rgba(255,255,255,1) 0%, rgba(250,251,252,1) 100%);
  border: 1px solid rgba(0, 0, 0, 0.05) !important;
  border-top: 6px solid var(--accent-primary) !important;
  border-radius: 12px !important;
  box-shadow: 0 12px 40px rgba(0, 0, 0, 0.1) !important;
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1) !important;
}

.section.level1:hover {
  border-top-color: var(--accent-secondary) !important;
  box-shadow: 0 18px 55px rgba(0, 0, 0, 0.15) !important;
  transform: translateY(-3px) !important;
}

h1 {
  font-size: 3.2rem !important;
  line-height: 1.05 !important;
  color: var(--text-dark) !important;
  font-weight: 700 !important;
  margin-bottom: 8px !important;
}

.subtitle {
  display: block;
  color: var(--accent-secondary);
  font-size: 1.05rem;
  font-weight: 500;
  margin-bottom: 14px;
  padding-left: 8px;
  border-left: 4px solid rgba(6,182,212,0.12);
}

h2 {
  font-size: 2.2em !important;
  color: var(--accent-primary) !important;
  margin-top: 50px !important;
  border-left: 8px solid var(--accent-secondary) !important;
  padding-left: 20px !important;
  transition: all 0.3s ease !important;
  font-weight: 600 !important;
}

h2:hover {
  padding-left: 25px !important;
  color: var(--accent-secondary) !important;
}

h3 {
  font-size: 1.6em !important;
  color: var(--accent-secondary) !important;
  border-left: 5px solid var(--accent-positive) !important;
  padding-left: 15px !important;
  margin-top: 30px !important;
  font-weight: 500 !important;
}

p {
  color: var(--text-dark) !important;
  font-size: 1.05em !important;
  line-height: 1.8 !important;
}

table {
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1) !important;
  border: 1px solid rgba(0, 0, 0, 0.05) !important;
  background: var(--bg-light) !important;
  border-radius: 10px !important;
  overflow: hidden !important;
  margin: 25px 0 !important;
}

thead {
  background: var(--accent-primary) !important;
}

th {
  color: var(--bg-light) !important;
  font-weight: 700 !important;
  padding: 15px 20px !important;
}

td {
  border-bottom: 1px solid var(--bg-lighter) !important;
  color: var(--text-dark) !important;
  padding: 12px 20px !important;
}

tbody tr:nth-child(even) {
  background-color: var(--bg-lighter) !important;
}

tbody tr:hover {
  background-color: rgba(6, 182, 212, 0.1) !important;
  transition: background-color 0.2s ease !important;
}

pre {
  background: var(--bg-lighter) !important;
  border-left: 6px solid var(--accent-secondary) !important;
  box-shadow: 0 6px 25px rgba(0, 0, 0, 0.08) !important;
  border: 1px solid rgba(6, 182, 212, 0.2) !important;
  border-radius: 10px !important;
  padding: 25px !important;
}

body .container-fluid,
body .main-container,
body div.container-fluid:first-of-type {
  margin-left: 280px !important;
  max-width: calc(100% - 300px) !important;
}

@media (max-width: 768px) {
  #custom-toc {
    position: relative !important;
    width: 100% !important;
    height: auto !important;
    max-height: 300px !important;
    margin-bottom: 30px !important;
  }
  
  div.container-fluid:first-of-type {
    padding: 20px !important;
  }
}

#uv-button {
  position: fixed;
  bottom: 25px;
  right: 25px;
  width: 70px;
  height: 70px;
  border-radius: 50%;
  background: white;
  box-shadow: 0 6px 18px rgba(0,0,0,0.25);
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  z-index: 9999;
  transition: transform 0.3s ease;
  overflow: hidden;
}

#uv-button:hover {
  transform: scale(1.1);
}

#uv-button img {
  width: 80%;
  height: 80%;
  object-fit: contain;
  transition: opacity .4s ease;
  display: block;
  margin: auto;        
  position: absolute;  
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

@keyframes spin-logo {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

#uv-button.spin {
  animation: spin-logo 1.2s linear;
}

#uv-button::after {
  content: attr(data-tooltip);
  position: absolute;
  left: -10px;
  top: 50%;
  transform: translate(-100%, -50%);
  background: rgba(0,0,0,0.85);
  color: white;
  padding: 8px 12px;
  font-size: 0.85em;
  border-radius: 6px;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.25s ease;
}

#uv-button:hover::after {
  opacity: 1;
}

#uv-button {
  position: fixed !important;
  z-index: 999999 !important;
  pointer-events: auto !important;
  overflow: visible !important;
}

#custom-toc {
  z-index: 5000 !important;
}

#global-code-toggle {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 10000;
  background: var(--accent-primary);
  color: white;
  border: none;
  padding: 10px 15px;
  border-radius: 8px;
  cursor: pointer;
  font-family: 'Inter', sans-serif;
  font-weight: 600;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  transition: all 0.3s ease;
}

#global-code-toggle:hover {
  background: var(--accent-secondary);
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(0,0,0,0.2);
}

.code-chunk-toggle {
  width: 100%;
  background: linear-gradient(135deg, var(--accent-secondary), var(--accent-primary));
  color: white;
  border: none;
  padding: 12px 20px;
  border-radius: 8px 8px 0 0;
  cursor: pointer;
  font-family: 'Inter', sans-serif;
  font-weight: 600;
  font-size: 0.95em;
  box-shadow: 0 4px 12px rgba(0, 184, 148, 0.2);
  transition: all 0.3s ease;
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0;
  position: relative;
  z-index: 100;
}

.code-chunk-toggle:hover {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  box-shadow: 0 6px 16px rgba(0, 184, 148, 0.3);
}

.code-chunk-toggle::after {
  content: "‚ñº";
  font-size: 1em;
  transition: transform 0.3s ease;
  display: inline-block;
}

.code-chunk-toggle.collapsed::after {
  transform: rotate(-180deg);
}

pre {
  margin-top: 0 !important;
  margin-bottom: 25px !important;
  transition: max-height 0.4s ease, opacity 0.4s ease;
  border-radius: 0 0 10px 10px;
}

pre.collapsed {
  max-height: 0 !important;
  overflow: hidden !important;
  margin-bottom: 0 !important;
  opacity: 0;
}

pre.expanded {
  max-height: 5000px !important;
  opacity: 1;
}

</style>
```

<div id="uv-button" data-tooltip="Escuela de Ingenier√≠a Industrial - Cali">
  <img id="uv-img" src="univalle.png" alt="Univalle">
</div>

```{=html}
<script>
document.addEventListener('DOMContentLoaded', function() {
  const SCROLL_OFFSET = 100;
  
  const toc = document.getElementById("custom-toc");
  if (!toc) return;

  const title = document.createElement("h2");
  title.textContent = "Contenido";
  toc.appendChild(title);
  
  const list = document.createElement("ul");
  toc.appendChild(list);

  const headers = document.querySelectorAll("h1, h2");
  
  headers.forEach(header => {
    if (!header.id) {
      header.id = header.textContent
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, '');
    }

    const li = document.createElement("li");
    const a = document.createElement("a");
    
    a.href = `#${header.id}`;
    a.textContent = header.textContent;
    
    a.addEventListener('click', function(e) {
      e.preventDefault();
      
      const targetId = this.getAttribute('href').substring(1);
      const targetElement = document.getElementById(targetId);
      
      if (targetElement) {
        window.scrollTo({
          top: targetElement.offsetTop - SCROLL_OFFSET, 
          behavior: 'smooth'
        });
        
        history.pushState(null, null, `#${targetId}`);
      }
    });

    li.appendChild(a);
    list.appendChild(li);
  });

  function updateActiveTOCLink() {
    const tocLinks = document.querySelectorAll('#custom-toc a');
    let currentActiveId = '';
    
    headers.forEach(section => {
      const rect = section.getBoundingClientRect();
      if (rect.top <= SCROLL_OFFSET + 20) { 
        currentActiveId = section.id;
      }
    });
    
    tocLinks.forEach(link => {
      link.classList.remove('active');
      if (link.getAttribute('href') === `#${currentActiveId}`) {
        link.classList.add('active');
      }
    });
  }

  window.addEventListener('scroll', updateActiveTOCLink);
  updateActiveTOCLink(); 

  const fechaSpan = document.getElementById('fecha-entrega');
  if(fechaSpan) {
    fechaSpan.textContent = new Date().toLocaleDateString('es-ES', {
      year: 'numeric', month: 'long', day: 'numeric'
    });
  }

  const btnToggle = document.createElement('button');
  btnToggle.id = 'global-code-toggle';
  btnToggle.textContent = 'üíª C√≥digo Oculto';
  document.body.appendChild(btnToggle);
  let codeVisible = true;
  btnToggle.addEventListener('click', function() {
    const codes = document.querySelectorAll('pre');
    const toggleBtns = document.querySelectorAll('.code-chunk-toggle');
    codeVisible = !codeVisible;
    codes.forEach(code => {
      code.style.display = codeVisible ? 'block' : 'none';
    });
    toggleBtns.forEach(btn => {
      if (codeVisible) {
        btn.style.display = 'flex';
      } else {
        btn.style.display = 'none';
      }
    });
    btnToggle.textContent = codeVisible ? 'üíª C√≥digo Oculto' : 'üëÅÔ∏è Mostrar C√≥digo';
  });

  setTimeout(() => {
    const preElements = document.querySelectorAll('pre');
    let chunkIndex = 0;
    
    preElements.forEach((pre) => {
      chunkIndex++;
      
      const btn = document.createElement('button');
      btn.className = 'code-chunk-toggle';
      btn.innerHTML = `<span>üíª C√≥digo - Chunk ${chunkIndex}</span>`;
      btn.setAttribute('data-chunk', chunkIndex);
      
      pre.classList.add('expanded');
      btn.classList.remove('collapsed');
      
      pre.parentNode.insertBefore(btn, pre);
      
      btn.addEventListener('click', function(e) {
        e.preventDefault();
        pre.classList.toggle('collapsed');
        pre.classList.toggle('expanded');
        btn.classList.toggle('collapsed');
      });
    });
  }, 500);

  const logos = ["univalle.png", "ingenieria.png"];  
  let index = 0;
  const img = document.getElementById("uv-img");
  const btn = document.getElementById("uv-button");
  if (btn && img) {
    setInterval(() => {
      btn.classList.add("spin");
      setTimeout(() => {
        index = (index + 1) % logos.length;
        img.style.opacity = 0;
        setTimeout(() => {
          img.src = logos[index];
          img.style.opacity = 1;
        }, 200);
      }, 600);
      setTimeout(() => btn.classList.remove("spin"), 1200);
    }, 3500);
  }
});
</script>
```

```{r setup, include=FALSE}
library(tidyverse)
library(quantmod)
library(xts)
library(fpp2)
library(tseries)
library(scales)
library(knitr)
library(kableExtra)
library(gridExtra)
library(grid)
library(forecast)
library(ggplot2)
library(zoo)
library(plotly)

knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.align = 'center',
  fig.width = 12,
  fig.height = 6
)

qqq_pal <- list(
  bg        = "#ffffff",
  text_dark = "#1f2937",
  text_gray = "#4b5563",
  primary   = "#00b894",
  secondary = "#06b6d4",
  positive  = "#84cc16",
  negative  = "#e17055",
  grid      = "#f3f4f6"
)

theme_QQQ <- function() {
  theme_minimal(base_size = 14) +
    theme(
      plot.background = element_rect(fill = "transparent", color = NA),
      panel.background = element_rect(fill = "transparent", color = NA),
      text = element_text(color = qqq_pal$text_dark, family = "sans"),
      plot.title = element_text(face = "bold", size = 16, color = qqq_pal$text_dark, margin = margin(b = 10)),
      plot.subtitle = element_text(size = 12, color = qqq_pal$secondary, margin = margin(b = 10)),
      plot.caption = element_text(size = 9, color = qqq_pal$text_gray, margin = margin(t = 10)),
      axis.title = element_text(face = "bold", size = 11, color = qqq_pal$text_gray),
      axis.text = element_text(size = 10, color = qqq_pal$text_gray),
      axis.line.x = element_line(color = qqq_pal$secondary, size = 0.5),
      panel.grid.major = element_line(color = qqq_pal$grid, linetype = "dashed"),
      panel.grid.minor = element_blank(),
      legend.position = "bottom",
      legend.background = element_rect(fill = "transparent", color = NA),
      legend.key = element_rect(fill = "transparent", color = NA)
    )
}

theme_set(theme_QQQ())
update_geom_defaults("line", list(color = qqq_pal$primary, size = 1.1))
update_geom_defaults("point", list(color = qqq_pal$secondary, size = 2))
update_geom_defaults("col", list(fill = qqq_pal$primary, color = NA))
```

---

# 1. Introducci√≥n

## 1.1 Relevancia del An√°lisis

[**PLACEHOLDER:** Explica la relevancia de QQQ, su importancia en el mercado global, volatilidad e impacto para inversionistas. Incluir contexto del Nasdaq-100 ETF.]

## 1.2 Metodolog√≠a: Modelos ARIMA

[**PLACEHOLDER:** Introducci√≥n a los conceptos fundamentales de ARIMA (Autorregresivos, Integrados, Media M√≥vil), su importancia te√≥rica y utilidad pr√°ctica en pron√≥sticos de series temporales financieras.]

---

# 2. Descripci√≥n de la Serie Temporal

## 2.1 Contexto Hist√≥rico y Datos

[**PLACEHOLDER:** Contexto completo del QQQ (Nasdaq-100 ETF), per√≠odo de an√°lisis seleccionado (octubre 2022 - presente), eventos significativos que han afectado el precio (crisis de volatilidad, cambios de pol√≠tica monetaria, rally de IA, etc.)]

```{r cargar-datos, echo=TRUE}

serie_QQQ <- getSymbols("QQQ", src="yahoo", auto.assign=FALSE, from="2015-01-01") 
Precio <- serie_QQQ$`QQQ.Close`

```

### Gr√°fico Din√°mico de la Serie

```{r serie-dinamica, echo=TRUE, fig.height=7}
datos_qqq <- data.frame(
  Fecha = index(Precio),
  Precio = as.numeric(Precio)
)

datos_qqq <- datos_qqq %>%
  mutate(Corte = as.yearqtr(Fecha)) 

lista_frames <- lapply(unique(datos_qqq$Corte), function(c) {
  dt <- datos_qqq[datos_qqq$Corte <= c, ]
  dt$Frame <- as.character(c) 
  return(dt)
})

datos_animados <- dplyr::bind_rows(lista_frames)

p <- ggplot(datos_animados, aes(x = Fecha, y = Precio)) +
  geom_area(aes(frame = Frame), fill = qqq_pal$primary, alpha = 0.1, position = "identity") +
  geom_line(aes(frame = Frame), color = qqq_pal$primary, size = 0.8) +
  labs(
    title = "Evoluci√≥n Din√°mica del QQQ",
    subtitle = "Crecimiento hist√≥rico acumulado desde octubre 2022",
    x = "", 
    y = "Precio (USD)"
  ) +
  scale_y_continuous(labels = scales::dollar_format()) +
  theme_QQQ() +
  theme(plot.title = element_text(size = 14))

plotly::ggplotly(p, tooltip = c("x", "y")) %>%
  plotly::layout(
    paper_bgcolor = 'rgba(0,0,0,0)',
    plot_bgcolor = 'rgba(0,0,0,0)',
    font = list(family = "Inter, sans-serif", color = qqq_pal$text_gray),
    hovermode = "x unified"
  ) %>%
  plotly::animation_opts(frame = 100, transition = 0, redraw = FALSE) %>%
  plotly::animation_slider(currentvalue = list(prefix = "Per√≠odo: ")) %>%
  plotly::config(displayModeBar = FALSE)
```

## 2.2 Estad√≠sticas Descriptivas

[**PLACEHOLDER:** Estad√≠sticas completas de la serie - Media, Mediana, Desv. Est., Rango, Cuartiles. Tablas formateadas con kableExtra.]

---

# 4. Resultados del Modelo ARIMA

## 4.1 Partici√≥n de Datos

### 4.1.1 Estrategia Train/Test

La aplicaci√≥n de modelos ARIMA para pron√≥stico de series temporales financieras requiere una estrategia de partici√≥n temporal que respete la naturaleza secuencial de los datos y simule condiciones reales de predicci√≥n. A diferencia de problemas de clasificaci√≥n o regresi√≥n donde la validaci√≥n cruzada aleatoria es apropiada, en series temporales es fundamental mantener el orden cronol√≥gico de las observaciones para evitar filtraci√≥n de informaci√≥n (data leakage) y garantizar que los datos de prueba representen verdaderas predicciones "fuera de muestra" realizadas sobre per√≠odos no observados durante la estimaci√≥n del modelo (Hyndman & Athanasopoulos, 2021).

La metodolog√≠a adoptada en este an√°lisis divide el conjunto completo de observaciones en dos subconjuntos temporales contiguos: un conjunto de entrenamiento (training set) utilizado para estimar los par√°metros de los modelos ARIMA candidatos, y un conjunto de prueba (test set) destinado a evaluar la capacidad predictiva sin sesgo, utilizando √∫nicamente el horizonte de pron√≥stico. Esta partici√≥n temporal es particularmente importante en contextos financieros donde los reg√≠menes de mercado cambian, los patrones de volatilidad evolucionan, y la informaci√≥n m√°s reciente tiende a ser m√°s relevante para la predicci√≥n que observaciones antiguas (Tsay, 2010).

El punto de divisi√≥n se establece en el 30 de septiembre de 2025, coincidiendo con el cierre del tercer trimestre del a√±o 2025. Esta fecha marca un quiebre administrativo natural en los calendarios financieros y evita arbitrariedades en la selecci√≥n del per√≠odo de corte. La estrategia asegura que aproximadamente el 95% de los datos hist√≥ricos se destinen al entrenamiento, proporcionando una base robusta para la estimaci√≥n de coeficientes ARIMA, mientras que el restante 5% permite validaci√≥n con un horizonte de pron√≥stico de 10 d√≠as h√°biles, consistente con los est√°ndares de an√°lisis de corto plazo en mercados financieros (Chatfield, 2000).

```{r particion-datos, echo=TRUE}
Entrenamiento <- window(Precio, start = "2022-10-07", end="2025-09-30")
Prueba <- window(Precio, start = "2025-10-01")
```

### 4.1.2 Tabla Resumen: Observaciones por Conjunto

```{r particion-tabla, echo=TRUE}
particion_resumen <- data.frame(
  Conjunto = c("Entrenamiento", "Prueba", "Total"),
  Per√≠odo = c(
    "07-Oct-2022 ‚Üí 30-Sep-2025",
    "01-Oct-2025 ‚Üí Presente",
    "07-Oct-2022 ‚Üí Presente"
  ),
  `Observaciones` = c(
    length(Entrenamiento),
    length(Prueba),
    length(Entrenamiento) + length(Prueba)
  ),
  Porcentaje = c(
    paste0(round(length(Entrenamiento)/(length(Entrenamiento)+length(Prueba))*100, 1), "%"),
    paste0(round(length(Prueba)/(length(Entrenamiento)+length(Prueba))*100, 1), "%"),
    "100%"
  ),
  Prop√≥sito = c(
    "Estimaci√≥n y validaci√≥n de modelo",
    "Evaluaci√≥n de capacidad predictiva",
    ""
  )
)

kable(particion_resumen,
      caption = "Resumen de Partici√≥n de Datos: Entrenamiento vs Prueba",
      align = c("l", "c", "c", "c", "l")) %>%
  kable_styling(bootstrap_options = c("hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(0, background = qqq_pal$primary, color = "white", bold = TRUE) %>%
  column_spec(1, bold = TRUE, color = qqq_pal$primary) %>%
  column_spec(3, bold = TRUE, color = qqq_pal$positive) %>%
  row_spec(3, bold = TRUE, background = "#e8f5e9", color = qqq_pal$text_dark)
```

### 4.1.3 Visualizaci√≥n: Serie con Partici√≥n 

```{r grafico-particion, echo=TRUE, fig.height=6.5}
df_train <- data.frame(
  Fecha = index(Entrenamiento),
  Precio = as.numeric(Entrenamiento),
  Conjunto = "Entrenamiento"
)

df_test <- data.frame(
  Fecha = index(Prueba),
  Precio = as.numeric(Prueba),
  Conjunto = "Prueba"
)

df_completo <- bind_rows(df_train, df_test)
fecha_corte <- as.Date("2025-10-01")

ggplot(df_completo, aes(x = Fecha, y = Precio)) +
  geom_ribbon(data = df_train, 
              aes(ymin = min(df_completo$Precio) * 0.95, ymax = Precio),
              fill = qqq_pal$primary, alpha = 0.08) +
  geom_ribbon(data = df_test, 
              aes(ymin = min(df_completo$Precio) * 0.95, ymax = Precio),
              fill = qqq_pal$secondary, alpha = 0.15) +
  geom_line(data = df_train, color = qqq_pal$primary, linewidth = 0.9) +
  geom_line(data = df_test, color = qqq_pal$secondary, linewidth = 1.1) +
  geom_vline(xintercept = fecha_corte, 
             linetype = "dashed", color = qqq_pal$negative, linewidth = 0.8) +
  annotate("text", x = fecha_corte, y = max(df_completo$Precio) * 1.02,
           label = "Corte: 01-Oct-2025", hjust = -0.05, vjust = 0,
           color = qqq_pal$negative, fontface = "bold", size = 3.5) +
  annotate("label", 
           x = as.Date("2024-01-01"), 
           y = max(df_completo$Precio) * 0.85,
           label = paste0("ENTRENAMIENTO\n", nrow(df_train), " observaciones"),
           fill = qqq_pal$primary, color = "white", 
           fontface = "bold", size = 3.5, label.padding = unit(0.5, "lines")) +
  annotate("label", 
           x = max(df_test$Fecha) - 10,
           y = min(df_completo$Precio) * 1.15,
           label = paste0("PRUEBA\n", nrow(df_test), " obs."),
           fill = qqq_pal$secondary, color = "white", 
           fontface = "bold", size = 3.2, label.padding = unit(0.4, "lines")) +
  scale_x_date(date_breaks = "4 months", date_labels = "%b %Y",
               expand = expansion(mult = c(0.02, 0.05))) +
  scale_y_continuous(labels = dollar_format(prefix = "$"),
                     expand = expansion(mult = c(0.05, 0.08))) +
  labs(
    title = "Partici√≥n de Datos: Entrenamiento vs Prueba",
    subtitle = "QQQ (Nasdaq-100 ETF) | Serie de precios de cierre diarios",
    x = NULL,
    y = "Precio de Cierre (USD)",
    caption = paste0("Fuente: Yahoo Finance | Per√≠odo: ", 
                     min(df_completo$Fecha), " a ", max(df_completo$Fecha))
  ) +
  theme_QQQ() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

La partici√≥n temporal establecida asegura cumplimiento con el requisito acad√©mico de m√≠nimo 60 per√≠odos de entrenamiento‚Äîel conjunto cuenta con 746 observaciones diarias (aproximadamente 3 a√±os de negociaci√≥n). El conjunto de prueba, con 40+ observaciones, proporciona suficiente horizonte para validar los 10 pron√≥sticos solicitados con m√°rgenes de seguridad estad√≠stica. La partici√≥n es no aleatoria y respeta el orden temporal, preservando autocorrelaciones y din√°micas de corto plazo que caracterizan a series financieras.

---

## 4.2 An√°lisis de Estacionariedad

Una serie temporal es estacionaria cuando sus propiedades estad√≠sticas fundamentales‚Äîmedia, varianza y funci√≥n de autocorrelaci√≥n‚Äîno dependen del tiempo (Hamilton, 1994). En contraste, una serie no estacionaria exhibe tendencias, cambios en nivel o varianza que evolucionan sistem√°ticamente, lo que viola supuestos cr√≠ticos del modelo $ARIMA$. La identificaci√≥n de estacionariedad es el primer paso metodol√≥gico en la aproximaci√≥n Box-Jenkins, ya que los modelos $ARIMA$ est√°n dise√±ados espec√≠ficamente para capturar estructura en series estacionarias; intentar ajustar $ARIMA$ a datos no estacionarios produce coeficientes espurios y pron√≥sticos infiables (Brockwell & Davis, 2016).

La detecci√≥n de no-estacionariedad se realiza mediante dos enfoques complementarios: an√°lisis visual de la funci√≥n de autocorrelaci√≥n (ACF) y pruebas estad√≠sticas formales. Desde la perspectiva visual, una serie no estacionaria presenta $ACF$ que decae lentamente a cero, permaneciendo significativamente diferente de cero incluso en rezagos lejanos (Chatfield, 2000). Esta caracter√≠stica refleja que la correlaci√≥n entre observaciones distantes sigue siendo elevada, indicador de ra√≠z unitaria. Formalmente, la prueba Aumentada de Dickey-Fuller (ADF) contrasta la hip√≥tesis nula de presencia de ra√≠z unitaria contra la alternativa de estacionariedad, permitiendo decisi√≥n estad√≠stica sobre la necesidad de diferenciaci√≥n (Dickey & Fuller, 1979).

Cuando se identifica no-estacionariedad, la transformaci√≥n mediante diferenciaci√≥n de orden dd
d convierte la serie en estacionaria. La diferenciaci√≥n de primer orden ($d=1$) calcula cambios diarios: $\nabla y_t = y_t - y_{t-1}$, removiendo tendencias lineales. Para el $QQQ$, donde el componente de tendencia es claramente visible, una √∫nica diferenciaci√≥n t√≠picamente es suficiente para alcanzar estacionariedad en series financieras (Tsay, 2010).

### 4.2.1 Serie en Niveles: Identificaci√≥n de No-Estacionariedad

La serie original de precios del QQQ exhibe un patr√≥n visual de tendencia alcista con fluctuaciones amplias alrededor de trayectoria creciente. El gr√°fico de autocorrelaci√≥n revela el s√≠ntoma cl√°sico de no-estacionariedad:

```{r acf-original, echo=TRUE, fig.height=5.5}
acf_data <- acf(Entrenamiento, lag.max = 30, plot = FALSE)

df_acf <- data.frame(
  Lag = acf_data$lag[-1], 
  ACF = acf_data$acf[-1]
)

n <- length(Entrenamiento)
limite_sup <- qnorm(0.975) / sqrt(n)
limite_inf <- -limite_sup

ggplot(df_acf, aes(x = Lag, y = ACF)) +
  geom_segment(aes(xend = Lag, yend = 0), 
               color = qqq_pal$primary, linewidth = 0.8) +
  geom_point(color = qqq_pal$primary, size = 2) +
  geom_hline(yintercept = limite_sup, linetype = "dashed", 
             color = qqq_pal$secondary, linewidth = 0.7) +
  geom_hline(yintercept = limite_inf, linetype = "dashed", 
             color = qqq_pal$secondary, linewidth = 0.7) +
  geom_hline(yintercept = 0, color = qqq_pal$text_gray, linewidth = 0.5) +
  annotate("rect", xmin = -Inf, xmax = Inf, 
           ymin = limite_inf, ymax = limite_sup,
           fill = qqq_pal$secondary, alpha = 0.1) +
  annotate("label", x = 20, y = 0.5,
           label = "Decaimiento lento\n‚Üí Serie NO estacionaria",
           fill = qqq_pal$negative, color = "white",
           fontface = "bold", size = 3.5, label.padding = unit(0.5, "lines")) +
  scale_x_continuous(breaks = seq(0, 30, 5)) +
  scale_y_continuous(limits = c(-0.1, 1.05), breaks = seq(0, 1, 0.25)) +
  labs(
    title = "Funci√≥n de Autocorrelaci√≥n (ACF) - Serie en Niveles",
    subtitle = "QQQ: Precio de cierre | Datos de entrenamiento",
    x = "Rezago (Lag)",
    y = "Autocorrelaci√≥n",
    caption = "Bandas azules: L√≠mites de significancia al 95%"
  ) +
  theme_QQQ()
```

La autocorrelaci√≥n muestral permanece elevada (>0.85) incluso en rezagos distantes (lag 30). Este decaimiento lento es el indicador cl√°sico de que la serie contiene ra√≠z unitaria y requiere diferenciaci√≥n (Brockwell & Davis, 2016). Adicionalmente, observamos que casi todos los rezagos caen fuera de las bandas de confianza, confirmando correlaci√≥n sistem√°tica estructural en la serie.

### 4.2.2 Prueba: Test de Dickey-Fuller Aumentado (ADF)

La prueba ADF contrasta formalmente: 
$$H_0: \text{Serie tiene ra√≠z unitaria (no-estacionaria)}$$
$$H_1: \text{Serie es estacionaria}$$
Un p-valor > 0.05 conduce al no-rechazo de $H_0$, confirmando no-estacionariedad:

```{r adf-original, echo=TRUE}
adf_resultado <- adf.test(Entrenamiento)

tabla_adf <- data.frame(
  M√©trica = c("Estad√≠stico Dickey-Fuller", 
              "Orden de Rezagos (Lag)", 
              "P-valor",
              "Nivel de Significancia (Œ±)",
              "Hip√≥tesis Nula (H‚ÇÄ)",
              "Decisi√≥n"),
  Valor = c(round(adf_resultado$statistic, 4),
            adf_resultado$parameter,
            round(adf_resultado$p.value, 4),
            "0.05",
            "Serie tiene ra√≠z unitaria",
            ifelse(adf_resultado$p.value > 0.05, 
                   "No rechazar H‚ÇÄ", "Rechazar H‚ÇÄ")),
  Interpretaci√≥n = c("Valor del estad√≠stico de prueba",
                     "Rezagos incluidos en el test",
                     "Probabilidad bajo H‚ÇÄ",
                     "Umbral de decisi√≥n",
                     "La serie NO es estacionaria",
                     ifelse(adf_resultado$p.value > 0.05,
                            "Serie NO estacionaria",
                            "Serie estacionaria ‚úì"))
)

kable(tabla_adf, 
      caption = "Prueba de Dickey-Fuller Aumentada (ADF) - Serie en Niveles",
      align = c("l", "c", "l")) %>%
  kable_styling(bootstrap_options = c("hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(0, background = qqq_pal$primary, color = "white", bold = TRUE) %>%
  row_spec(3, bold = TRUE, color = qqq_pal$negative, background = "#ffe8e0") %>% 
  row_spec(6, bold = TRUE, background = "#fef3f2", color = qqq_pal$text_dark)
```

El estad√≠stico ADF de -3.0468 es mayor (menos negativo) que el valor cr√≠tico aproximado de -3.43 para significancia al 5%. Con p-valor de 0.1352 > 0.05, no se rechaza $H_0$: la serie de precios en niveles es no-estacionaria (DickeyFuller, 1979). Esta evidencia estad√≠stica justifica la aplicaci√≥n de diferenciaci√≥n.

### 4.2.3 Aplicaci√≥n de Diferenciaci√≥n de Primer Orden

La transformaci√≥n $\nabla y_t = y_t - y_{t-1}$ convierte precios en cambios diarios, removiendo la tendencia de largo plazo:

```{r diferenciacion, echo=TRUE}
dif_Entrenamiento <- diff(Entrenamiento) %>% na.omit()
```

```{r grafico-diferenciada, echo=TRUE, fig.height=6}
df_diff <- data.frame(
  Fecha = index(dif_Entrenamiento),
  Valor = as.numeric(dif_Entrenamiento)
)

ggplot(df_diff, aes(x = Fecha, y = Valor)) +
  geom_line(color = qqq_pal$secondary, linewidth = 0.6) +
  geom_hline(yintercept = 0, linetype = "dashed", 
             color = qqq_pal$primary, linewidth = 0.7) +
  annotate("label", 
           x = as.Date("2023-06-01"), 
           y = max(df_diff$Valor) * 0.85,
           label = paste0("Media ‚âà ", round(mean(df_diff$Valor), 3)),
           fill = qqq_pal$primary, color = "white",
           fontface = "bold", size = 3.5, label.padding = unit(0.4, "lines")) +
  scale_x_date(date_breaks = "4 months", date_labels = "%b %Y",
               expand = expansion(mult = c(0.02, 0.03))) +
  scale_y_continuous(labels = scales::dollar_format(prefix = "$"),
                     expand = expansion(mult = c(0.05, 0.08))) +
  labs(
    title = "Serie Diferenciada de Primer Orden (d = 1)",
    subtitle = "QQQ: Cambios diarios en precio de cierre | Datos de entrenamiento",
    x = NULL,
    y = "Cambio Diario (USD)",
    caption = paste0("Observaciones: ", nrow(df_diff), 
                     " | Per√≠odo: ", min(df_diff$Fecha), " a ", max(df_diff$Fecha))
  ) +
  theme_QQQ() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

La serie diferenciada oscila alrededor de media aproximadamente cero (0.444), sin tendencia visual evidente. La volatilidad var√≠a a lo largo del per√≠odo‚Äîper√≠odos de calma alternando con volatilidad elevada‚Äîpero la media permanece relativamente constante, caracter√≠stica fundamental de estacionariedad (Hamilton, 1994).

### 4.2.3 Verificaci√≥n Post-Diferenciaci√≥n

La validaci√≥n de estacionariedad post-diferenciaci√≥n combina an√°lisis ACF y test ADF:

```{r acf-diferenciada, echo=TRUE, fig.height=5.5}
acf_diff_data <- acf(dif_Entrenamiento, lag.max = 30, plot = FALSE)

df_acf_diff <- data.frame(
  Lag = acf_diff_data$lag[-1],
  ACF = acf_diff_data$acf[-1]
)

n_diff <- length(dif_Entrenamiento)
limite_sup_diff <- qnorm(0.975) / sqrt(n_diff)
limite_inf_diff <- -limite_sup_diff

ggplot(df_acf_diff, aes(x = Lag, y = ACF)) +
  geom_segment(aes(xend = Lag, yend = 0), 
               color = qqq_pal$secondary, linewidth = 0.8) +
  geom_point(color = qqq_pal$secondary, size = 2) +
  geom_hline(yintercept = limite_sup_diff, linetype = "dashed", 
             color = qqq_pal$primary, linewidth = 0.7) +
  geom_hline(yintercept = limite_inf_diff, linetype = "dashed", 
             color = qqq_pal$primary, linewidth = 0.7) +
  geom_hline(yintercept = 0, color = qqq_pal$text_gray, linewidth = 0.5) +
  annotate("rect", xmin = -Inf, xmax = Inf, 
           ymin = limite_inf_diff, ymax = limite_sup_diff,
           fill = qqq_pal$primary, alpha = 0.1) +
  annotate("label", x = 22, y = 0.12,
           label = "Autocorrelaciones dentro\nde bandas ‚Üí Estacionaria ‚úì",
           fill = qqq_pal$positive, color = "white",
           fontface = "bold", size = 3.5, label.padding = unit(0.5, "lines")) +
  scale_x_continuous(breaks = seq(0, 30, 5)) +
  scale_y_continuous(limits = c(-0.15, 0.2), breaks = seq(-0.1, 0.2, 0.05)) +
  labs(
    title = "Funci√≥n de Autocorrelaci√≥n (ACF) - Serie Diferenciada",
    subtitle = "QQQ: Cambios diarios | Verificaci√≥n de estacionariedad post-diferenciaci√≥n",
    x = "Rezago (Lag)",
    y = "Autocorrelaci√≥n",
    caption = "Bandas verdes: L√≠mites de significancia al 95%"
  ) +
  theme_QQQ()
```

La mayor√≠a de autocorrelaciones caen dentro de las bandas de confianza (regi√≥n verde). Solo algunos rezagos (principalmente lag 1, 18, 20) muestran significancia marginal, pero el patr√≥n general indica ausencia de ra√≠z unitaria. Este contraste con el $ACF$ de la serie original es dram√°tico y valida la diferenciaci√≥n.

```{r adf-diferenciada, echo=TRUE}
adf_diff_resultado <- adf.test(dif_Entrenamiento)

tabla_adf_diff <- data.frame(
  M√©trica = c("Estad√≠stico Dickey-Fuller", 
              "Orden de Rezagos (Lag)", 
              "P-valor",
              "Nivel de Significancia (Œ±)",
              "Hip√≥tesis Nula (H‚ÇÄ)",
              "Decisi√≥n"),
  Valor = c(round(adf_diff_resultado$statistic, 4),
            adf_diff_resultado$parameter,
            round(adf_diff_resultado$p.value, 4),
            "0.05",
            "Serie tiene ra√≠z unitaria",
            ifelse(adf_diff_resultado$p.value < 0.05, 
                   "Rechazar H‚ÇÄ", "No rechazar H‚ÇÄ")),
  Interpretaci√≥n = c("Valor del estad√≠stico de prueba",
                     "Rezagos incluidos en el test",
                     "Probabilidad bajo H‚ÇÄ",
                     "Umbral de decisi√≥n",
                     "La serie NO es estacionaria",
                     ifelse(adf_diff_resultado$p.value < 0.05,
                            "Serie ES estacionaria ‚úì",
                            "Serie NO estacionaria"))
)

kable(tabla_adf_diff, 
      caption = "Prueba de Dickey-Fuller Aumentada (ADF) - Serie Diferenciada (d=1)",
      align = c("l", "c", "l")) %>%
  kable_styling(bootstrap_options = c("hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(0, background = qqq_pal$primary, color = "white", bold = TRUE) %>%
  row_spec(3, bold = TRUE, color = qqq_pal$positive, background = "#e8f5e9") %>%
  row_spec(6, bold = TRUE, background = "#d4edda", color = qqq_pal$text_dark)
```

El estad√≠stico ADF de -8.6831 es altamente negativo, muy inferior al valor cr√≠tico de -3.43. Con p-valor de 0.01 < 0.05, se rechaza $H_0$ con confianza
. La serie diferenciada es estacionaria (Dickey & Fuller, 1979). Por tanto, el par√°metro de integraci√≥n en ARIMA es $d=1$: una √∫nica diferenciaci√≥n convierte la serie no-estacionaria de precios en una serie estacionaria de cambios diarios, cumpliendo con el supuesto fundamental requerido por la metodolog√≠a Box-Jenkins (Box & Jenkins, 1976).

---

## 4.3 Identificaci√≥n del Modelo

Una vez verificada la estacionariedad de la serie mediante diferenciaci√≥n de primer orden, el siguiente paso metodol√≥gico consiste en identificar los √≥rdenes $p$ (autorregresivo) y $q$ (media m√≥vil) de la estructura $ARIMA(p,d,q)$. Este proceso de identificaci√≥n representa el coraz√≥n del m√©todo Box-Jenkins: utiliza funciones de autocorrelaci√≥n muestral para extraer informaci√≥n sobre la dependencia temporal que la serie diferenciada contiene (Box & Jenkins, 1976; Brockwell & Davis, 2016).

La funci√≥n de autocorrelaci√≥n (ACF) cuantifica correlaciones lineales entre pares de observaciones separadas por rezagos 1, 2, 3, ... k. Para una serie estacionaria, el $ACF$ tiende hacia cero conforme aumenta el rezago, decayendo eventualmente dentro de bandas de confianza. La estructura del decaimiento revela informaci√≥n sobre la naturaleza del componente media m√≥vil: si el $ACF$ presenta picos significativos aislados en los primeros rezagos (por ejemplo, solo lag 1 o lag 2 fuera de bandas) y luego decae r√°pidamente a cero, esto sugiere que un modelo $MA(q)$ con q peque√±o puede capturar adecuadamente la din√°mica (Hamilton, 1994; Tsay, 2010).

La funci√≥n de autocorrelaci√≥n parcial (PACF) cuantifica correlaciones despu√©s de remover el efecto de rezagos intermedios. Matem√°ticamente, la autocorrelaci√≥n parcial en rezago k se define como el coeficiente autorregresivo en una regresi√≥n de la serie contra s√≠ misma en rezagos 1 hasta k, habiendo eliminado variabilidad explicada por rezagos 1 hasta k-1. La $PACF$ revela informaci√≥n complementaria sobre el componente autorregresivo: si la $PACF$ presenta picos significativos decayendo lentamente (varios rezagos significativos) mientras el $ACF$ decae r√°pidamente, esto sugiere un modelo $AR(p)$ con $p$ moderado (Box & Jenkins, 1976; Hastie et al., 2009).

### 4.3.1 An√°lisis ACF/PACF - Serie Diferenciada

```{r acf-pacf-dual, echo=TRUE, fig.height=6}
acf_data <- acf(dif_Entrenamiento, lag.max = 28, plot = FALSE)
pacf_data <- pacf(dif_Entrenamiento, lag.max = 28, plot = FALSE)

df_acf <- data.frame(
  Lag = as.numeric(acf_data$lag[-1]),
  Valor = as.numeric(acf_data$acf[-1])
)

df_pacf <- data.frame(
  Lag = as.numeric(pacf_data$lag),
  Valor = as.numeric(pacf_data$acf)
)

n <- length(dif_Entrenamiento)
limite <- qnorm(0.975) / sqrt(n)

p_acf <- ggplot(df_acf, aes(x = Lag, y = Valor)) +
  geom_hline(yintercept = 0, color = qqq_pal$text_gray, linewidth = 0.5) +
  geom_hline(yintercept = c(-limite, limite), linetype = "dashed", 
             color = qqq_pal$secondary, linewidth = 0.6) +
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = -limite, ymax = limite,
           fill = qqq_pal$secondary, alpha = 0.08) +
  geom_segment(aes(xend = Lag, yend = 0), color = qqq_pal$primary, linewidth = 0.7) +
  geom_point(color = qqq_pal$primary, size = 1.5) +
  scale_x_continuous(breaks = seq(0, 28, 5)) +
  scale_y_continuous(limits = c(-0.15, 0.12)) +
  labs(title = "ACF - Serie Diferenciada",
       subtitle = "Identificaci√≥n del orden q (MA)",
       x = "Rezago (Lag)",
       y = "ACF") +
  theme_QQQ() +
  theme(plot.title = element_text(size = 12))

p_pacf <- ggplot(df_pacf, aes(x = Lag, y = Valor)) +
  geom_hline(yintercept = 0, color = qqq_pal$text_gray, linewidth = 0.5) +
  geom_hline(yintercept = c(-limite, limite), linetype = "dashed", 
             color = qqq_pal$secondary, linewidth = 0.6) +
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = -limite, ymax = limite,
           fill = qqq_pal$secondary, alpha = 0.08) +
  geom_segment(aes(xend = Lag, yend = 0), color = qqq_pal$primary, linewidth = 0.7) +
  geom_point(color = qqq_pal$primary, size = 1.5) +
  scale_x_continuous(breaks = seq(0, 28, 5)) +
  scale_y_continuous(limits = c(-0.15, 0.12)) +
  labs(title = "PACF - Serie Diferenciada",
       subtitle = "Identificaci√≥n del orden p (AR)",
       x = "Rezago (Lag)",
       y = "PACF") +
  theme_QQQ() +
  theme(plot.title = element_text(size = 12))

grid.arrange(p_acf, p_pacf, ncol = 2)
```

El an√°lisis visual del $ACF$ y $PACF$ de la serie diferenciada del $QQQ$ revela patrones que son caracter√≠sticos de mercados financieros eficientes. En el $ACF$ (panel izquierdo), se observa que la mayor√≠a de autocorrelaciones caen dentro de las bandas de confianza te√≥ricas para todos los rezagos hasta lag 28. Esta ausencia sistem√°tica de autocorrelaciones significativas se interpreta seg√∫n la hip√≥tesis de mercado eficiente (EMH): los precios de activos seguros incorporan informaci√≥n disponible p√∫blicamente, dejando en los retornos una estructura pr√°cticamente aleatoria sin dependencias predecibles (Fama, 1970; Malkiel, 1973). La presencia de algunas autocorrelaciones leves (por ejemplo, alrededor de lag 17-20) no alcanza magnitud para ser interpretada como estructura genuina sino m√°s bien como ruido muestral esperado en series finitas.

El $PACF$ (panel derecho) exhibe un patr√≥n complementario: nuevamente, la mayor√≠a de autocorrelaciones parciales se ubican dentro de bandas de confianza, con excepci√≥n de quiz√°s lag 1 que muestra una peque√±a autocorrelaci√≥n parcial negativa. En conjunto, el an√°lisis $ACF/PACF$ sugiere que la serie diferenciada es cercana a ruido blanco, es decir, una secuencia de innovaciones aleatorias sin estructura de dependencia predecible. Este hallazgo tiene implicaciones profundas: implica que cualquier modelo $ARIMA$ que intente capturar estructura en precios del $QQQ$ estar√° fundamentalmente limitado en su capacidad predictiva, capturando quiz√°s un componente peque√±o de ineficiencia de mercado de corto plazo m√°s que una estructura genuina de largo plazo (Tsay, 2010; Hamilton, 1994).

### 4.3.2 Modelos ARIMA Candidatos

Dada la evidencia de escasa estructura predecible en los correlogramas, la identificaci√≥n manual procede evaluando un conjunto de modelos candidatos que van desde el m√°s simple (ARIMA(0,1,0), random walk puro) hasta especificaciones progresivamente m√°s complejas. La estrategia de selecci√≥n combina tres criterios complementarios: (i) plausibilidad te√≥rica basada en observaci√≥n de $ACF/PACF$, (ii) parsimonia (principio de m√°xima simplicidad), y (iii) comparaci√≥n formal mediante criterios de informaci√≥n que balancean bondad de ajuste contra n√∫mero de par√°metros (Hyndman & Athanasopoulos, 2021).

```{r modelos-candidatos-tabla, echo=TRUE}
tabla_candidatos <- data.frame(
  Modelo = c("ARIMA(0,1,0)", 
             "ARIMA(1,1,1)",
             "ARIMA(2,1,1)", 
             "ARIMA(1,1,2)",
             "ARIMA(2,1,2)",
             "ARIMA(3,1,3)"),
  Tipo = c("Random Walk",
           "auto.arima()",
           "Manual",
           "Manual",
           "Manual",
           "Exploratorio"),
  `Observaci√≥n ACF/PACF` = c(
    "Patr√≥n general cercano a ruido blanco",
    "Selecci√≥n autom√°tica por AICc",
    "Posible estructura en lags 1-2 del PACF",
    "Posible estructura en lags 1-2 del ACF",
    "Combinaci√≥n de estructuras en ambos correlogramas",
    "Pico marginal en lag 3 de ambos correlogramas"
  ),
  Justificaci√≥n = c(
    "Benchmark obligatorio: hip√≥tesis de mercado eficiente",
    "Referencia algor√≠tmica para validar selecci√≥n manual",
    "Extensi√≥n AR(2) para capturar persistencia de corto plazo",
    "Extensi√≥n MA(2) para capturar estructura de media m√≥vil",
    "Modelo sim√©trico que combina din√°micas AR y MA",
    "Evaluar si rezagos marginales aportan capacidad predictiva"
  )
)

kable(tabla_candidatos,
      caption = "Modelos ARIMA Candidatos para Evaluaci√≥n",
      align = c("l", "c", "l", "l"),
      col.names = c("Modelo", "Tipo", "Observaci√≥n en ACF/PACF", "Justificaci√≥n")) %>%
  kable_styling(bootstrap_options = c("hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(0, background = qqq_pal$primary, color = "white", bold = TRUE) %>%
  column_spec(1, bold = TRUE, color = qqq_pal$primary) %>%
  column_spec(2, color = qqq_pal$secondary) %>%
  column_spec(3, width = "18em") %>%
  column_spec(4, width = "22em") %>%
  row_spec(2, background = "#e8f5e9", color = qqq_pal$text_dark, bold = TRUE)
```

La selecci√≥n de estos seis modelos candidatos obedece a una l√≥gica progresiva de complejidad. El $ARIMA(0,1,0)$‚Äîconocido como random walk en finanzas‚Äîrepresenta la hip√≥tesis nula de mercado eficiente: no existe estructura explorable, y el mejor pron√≥stico del precio ma√±ana es simplemente el precio hoy m√°s una innovaci√≥n aleatoria. Este modelo act√∫a como benchmark obligatorio contra el cual se eval√∫an modelos m√°s sofisticados (Fama, 1970; Malkiel, 1973).
El $ARIMA(1,1,1)$ fue seleccionado por la funci√≥n `auto.arima()` que utiliza criterios de informaci√≥n (Akaike, BIC) para seleccionar autom√°ticamente √≥rdenes. Este modelo es el m√°s parsimonioso que a√±ade estructura genuina: un componente autorregresivo captura dependencia del precio rezagado un per√≠odo, mientras que un componente media m√≥vil captura el efecto de innovaciones rezagadas. La funci√≥n de verosimilitud bajo $ARIMA(1,1,1)$ captura un componente adicional de dependencia que no existe en el random walk puro, aunque sea peque√±o (Tsay, 2010).
El $ARIMA(2,1,1)$ extiende el componente $AR$ a dos rezagos para evaluar si la persistencia de corto plazo requiere m√°s de un rezago hist√≥rico. El $ARIMA(1,1,2)$ extiende en cambio el componente $MA$, explorando si el efecto de innovaciones requiere dos per√≠odos de memoria. El $ARIMA(2,1,2)$ representa un modelo sim√©trico que combina ambas din√°micas. El $ARIMA(3,1,3)$ es explorador: examina si picos marginales observados alrededor de lag 3 en los correlogramas representan estructura genuina o simplemente ruido muestral (Hamilton, 1994; Box & Jenkins, 1976).

---

## 4.4 Estimaci√≥n y Comparaci√≥n de Modelos

### 4.4.1 Criterios de Informaci√≥n
```{r ajuste-modelos, echo=TRUE}
ModeloQA <- auto.arima(Entrenamiento)
modeloQ1 <- Arima(Entrenamiento, order = c(3,1,3))
modeloQ2 <- Arima(Entrenamiento, order = c(0,1,0))
modeloQ3 <- Arima(Entrenamiento, order = c(2,1,1))
modeloQ4 <- Arima(Entrenamiento, order = c(1,1,2))
modeloQ5 <- Arima(Entrenamiento, order = c(2,1,2))
```

```{r criterios-informacion, echo=TRUE}
comparacion_IC <- data.frame(
  Modelo = c("ARIMA(0,1,0)", 
             "ARIMA(1,1,1) + drift", 
             "ARIMA(2,1,1)", 
             "ARIMA(1,1,2)",
             "ARIMA(2,1,2)",
             "ARIMA(3,1,3)"),
  Parametros = c(length(coef(modeloQ2)) + 1,
                 length(coef(ModeloQA)) + 1,
                 length(coef(modeloQ3)) + 1,
                 length(coef(modeloQ4)) + 1,
                 length(coef(modeloQ5)) + 1,
                 length(coef(modeloQ1)) + 1),
  AIC = round(c(AIC(modeloQ2), 
                AIC(ModeloQA), 
                AIC(modeloQ3), 
                AIC(modeloQ4),
                AIC(modeloQ5),
                AIC(modeloQ1)), 2),
  AICc = round(c(modeloQ2$aicc, 
                 ModeloQA$aicc, 
                 modeloQ3$aicc, 
                 modeloQ4$aicc,
                 modeloQ5$aicc,
                 modeloQ1$aicc), 2),
  BIC = round(c(BIC(modeloQ2), 
                BIC(ModeloQA), 
                BIC(modeloQ3), 
                BIC(modeloQ4),
                BIC(modeloQ5),
                BIC(modeloQ1)), 2)
)

comparacion_IC <- comparacion_IC %>%
  arrange(AICc) %>%
  mutate(Ranking = row_number()) %>%
  select(Ranking, Modelo, Parametros, AIC, AICc, BIC)

kable(comparacion_IC,
      caption = "Comparaci√≥n de Modelos por Criterios de Informaci√≥n",
      align = c("c", "l", "c", "c", "c", "c"),
      col.names = c("Ranking", "Modelo", "# Par√°metros", "AIC", "AICc", "BIC")) %>%
  kable_styling(bootstrap_options = c("hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(0, background = qqq_pal$primary, color = "white", bold = TRUE) %>%
  column_spec(2, bold = TRUE, color = qqq_pal$primary) %>%
  column_spec(5, bold = TRUE, color = qqq_pal$positive) %>%
  row_spec(1, bold = TRUE, background = "#e8f5e9", color = qqq_pal$text_dark) %>%
  footnote(general = "Ordenado por AICc (menor es mejor). AICc es el criterio preferido para muestras finitas.",
           general_title = "Nota: ")
```

La comparaci√≥n mediante criterios de informaci√≥n representa la etapa cuantitativa de la selecci√≥n de modelos. Estos criterios resuelven un dilema fundamental en modelado estad√≠stico: modelos m√°s complejos (m√°s par√°metros) siempre se ajustan mejor a los datos (menor residuos), pero esta mejora puede ser simplemente overfitting‚Äîcapturar ruido aleatorio en lugar de estructura genuina (Hastie et al., 2009; Hyndman & Athanasopoulos, 2021).

El Criterio de Informaci√≥n de Akaike (AIC) y su variante corregida para muestras finitas (AICc) resuelven este trade-off penalizando modelos por n√∫mero de par√°metros. Formalmente, $AICc = -2‚Ñì + 2k + 2k(k+1)/(n-k-1)$, donde $‚Ñì$ es la log-verosimilitud m√°xima, k es el n√∫mero de par√°metros, y $n$ es el tama√±o muestral (Burnham & Anderson, 2002; Tsay, 2010). Para muestras finitas t√≠picas en series de tiempo (como nuestro caso con n=746 observaciones), $AICc$ es superior a $AIC$ porque aplica penalizaci√≥n m√°s severa por par√°metros adicionales. El $BIC$ (Bayesian Information Criterion), alternativa, aplica penalizaci√≥n a√∫n m√°s severa: $BIC = -2‚Ñì + k¬∑ln(n)$, haciendo que $BIC$ favorezca modelos muy simples (Hamilton, 1994).

En nuestro an√°lisis, el $ARIMA(1,1,1)$ + drift emerge como ganador indiscutible con $AICc$ = 4663.94, significativamente menor que $ARIMA(2,1,2)$ (4668.14, ranking 2) y todos los dem√°s modelos. Esta diferencia de 4.2 puntos en $AICc$ entre ranking 1 y 2 es sustancial: seg√∫n regla de oro de Burnham & Anderson (2002), diferencias >10 en $AICc$ indican que modelo inferior tiene esencialmente probabilidad posterior negligible; diferencias entre 4-7 indican soporte moderado para modelo superior. La diferencia de 4.2 en nuestro caso es clara aunque no dram√°tica, validando $ARIMA(1,1,1)$ como notablemente superior.

El t√©rmino "drift" en $ARIMA(1,1,1)$ + drift representa una constante en la ecuaci√≥n de diferencias: $‚àáy_t = Œº + œÜ‚ÇÅ‚àáy_{t-1} + Œ∏‚ÇÅŒµ_{t-1} + Œµ_t$, donde Œº captura tendencia lineal impl√≠cita en la serie. En econom√≠a financiera, el drift representa el retorno esperado promedio (equity premium): durante el per√≠odo de an√°lisis (2022-2025), el $QQQ$ exhibi√≥ movimiento alcista promedio (drift positivo), reflejando optimismo en tecnolog√≠a pese a volatilidad. El algoritmo `auto.arima()` seleccion√≥ autom√°ticamente este drift porque mejor√≥ sustancialmente el criterio $AICc$ (Brockwell & Davis, 2016).

La evaluaci√≥n de modelos m√°s complejos (ARIMA(3,1,3) con 7 par√°metros) revela el problema de sobreparametrizaci√≥n: aunque tiene $AIC$ m√°s bajo (4669.04), su $AICc$ es 4669.19 (ranking 6) porque la penalizaci√≥n por 7 par√°metros domina cualquier mejora marginal en ajuste. Este es un caso de castigo de parsimonia: modelo m√°s complejo no justifica su complejidad. El $ARIMA(0,1,0)$ (random walk puro), por el contrario, es m√°s parsimonioso (1 par√°metro) pero produce $AICc =$ 4668.39 (ranking 3), confirmando lo que los correlogramas sugirieron: estructura existe aunque sea peque√±a, y modelo m√°s complejo la captura mejor que modelo m√°s simple.

### 4.4.2 M√©tricas de Precisi√≥n en Entrenamiento


```{r metricas-precision, echo=TRUE}
acc_QA <- accuracy(ModeloQA)
acc_Q1 <- accuracy(modeloQ1)
acc_Q2 <- accuracy(modeloQ2)
acc_Q3 <- accuracy(modeloQ3)
acc_Q4 <- accuracy(modeloQ4)
acc_Q5 <- accuracy(modeloQ5)

comparacion_accuracy <- data.frame(
  Modelo = c("ARIMA(0,1,0)", 
             "ARIMA(1,1,1) + drift", 
             "ARIMA(2,1,1)", 
             "ARIMA(1,1,2)",
             "ARIMA(2,1,2)",
             "ARIMA(3,1,3)"),
  ME = round(c(acc_Q2["Training set", "ME"], 
               acc_QA["Training set", "ME"], 
               acc_Q3["Training set", "ME"], 
               acc_Q4["Training set", "ME"],
               acc_Q5["Training set", "ME"],
               acc_Q1["Training set", "ME"]), 4),
  RMSE = round(c(acc_Q2["Training set", "RMSE"], 
                 acc_QA["Training set", "RMSE"], 
                 acc_Q3["Training set", "RMSE"], 
                 acc_Q4["Training set", "RMSE"],
                 acc_Q5["Training set", "RMSE"],
                 acc_Q1["Training set", "RMSE"]), 4),
  MAE = round(c(acc_Q2["Training set", "MAE"], 
                acc_QA["Training set", "MAE"], 
                acc_Q3["Training set", "MAE"], 
                acc_Q4["Training set", "MAE"],
                acc_Q5["Training set", "MAE"],
                acc_Q1["Training set", "MAE"]), 4),
  MAPE = round(c(acc_Q2["Training set", "MAPE"], 
                 acc_QA["Training set", "MAPE"], 
                 acc_Q3["Training set", "MAPE"], 
                 acc_Q4["Training set", "MAPE"],
                 acc_Q5["Training set", "MAPE"],
                 acc_Q1["Training set", "MAPE"]), 4),
  MASE = round(c(acc_Q2["Training set", "MASE"], 
                 acc_QA["Training set", "MASE"], 
                 acc_Q3["Training set", "MASE"], 
                 acc_Q4["Training set", "MASE"],
                 acc_Q5["Training set", "MASE"],
                 acc_Q1["Training set", "MASE"]), 4)
)

comparacion_accuracy <- comparacion_accuracy %>%
  arrange(RMSE) %>%
  mutate(Ranking = row_number()) %>%
  select(Ranking, Modelo, ME, RMSE, MAE, MAPE, MASE)

kable(comparacion_accuracy,
      caption = "M√©tricas de Precisi√≥n sobre Datos de Entrenamiento",
      align = c("c", "l", rep("c", 5))) %>%
  kable_styling(bootstrap_options = c("hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(0, background = qqq_pal$primary, color = "white", bold = TRUE) %>%
  column_spec(2, bold = TRUE, color = qqq_pal$primary) %>%
  column_spec(4, bold = TRUE, color = qqq_pal$positive) %>%
  row_spec(1, background = "#e8f5e9", color = qqq_pal$text_dark, bold = TRUE) %>%
  footnote(general = "ME: Error Medio | RMSE: Ra√≠z del Error Cuadr√°tico Medio | MAE: Error Absoluto Medio | MAPE: Error Porcentual (%) | MASE: Error Escalado",
           general_title = "M√©tricas: ")
```

Las m√©tricas de precisi√≥n cuantifican c√≥mo cada modelo se desempe√±a al predecir observaciones en el conjunto de entrenamiento. Mientras que criterios de informaci√≥n (AIC, AICc) eval√∫an trade-off entre ajuste y complejidad de manera agregada, las m√©tricas permiten inspeccionar la naturaleza exacta de los errores de predicci√≥n (Hyndman & Athanasopoulos, 2021; Tsay, 2010).

El Error Medio (ME) cuantifica sesgo: si $ME$ es cercano a cero, las predicciones son insesgadas en promedio; si es positivo/negativo, el modelo subestima/sobrestima sistem√°ticamente. En nuestro caso, todos los modelos exhiben $ME$ cercano a cero (rango: -0.0001 a 0.4939), confirmando que son aproximadamente insesgados. El $ARIMA(1,1,1)$ + drift tiene $ME =$ -0.0001, virtualmente perfecto en t√©rminos de sesgo.

La Ra√≠z del Error Cuadr√°tico Medio (RMSE) cuantifica dispersi√≥n de errores, penalizando errores grandes m√°s severamente que errores peque√±os (por la elevaci√≥n al cuadrado). El $ARIMA(3,1,3)$ lidera con $RMSE =$ 5.4759, marginalmente inferior a $ARIMA(1,1,1)$ + drift (5.4792). Esta diferencia de 0.0033 es negligible en t√©rminos pr√°cticos: representa 0.06% mejora, mientras que $ARIMA(3,1,3)$ requiere m√°s par√°metros (7 versus 4). Por regla de retornos decrecientes, esta mejora no justifica complejidad adicional (Hastie et al., 2009).

El Error Absoluto Medio (MAE) es alternativa robusta a $RMSE$, sin penalizaci√≥n cuadrada: simplemente promedio de valores absolutos de errores. $MAE$ tiene interpretaci√≥n directa: en promedio, predicciones del $ARIMA(1,1,1)$ + drift se desv√≠an ¬±3.8704 puntos del valor real en el espacio de precios del $QQQ$. Para un ETF con precios t√≠picamente entre $200-500, desviaci√≥n de ¬±4 puntos representa error de ~1-2% en t√©rminos relativos.

El Porcentaje de Error Absoluto Medio (MAPE) normaliza por escala: error promedio como porcentaje del valor observado. Todos los modelos reportan $MAPE$ alrededor de 0.94%, validando que errores son peque√±os relativamente. El $ARIMA(1,1,1)$ + drift obtiene $MAPE =$ 0.9445%, indicando que predicciones erran en promedio menos de 1% del valor real.

El Error Escalado Medio Absoluto (MASE), m√©trica de Hyndman & Koehler (2006), normaliza por el desempe√±o de un benchmark na√Øf (predictor que simplemente repite el valor anterior, es decir, random walk). Si $MASE$ < 1, el modelo supera al random walk; si $MASE$ > 1, el modelo es peor. Todos los modelos presentan $MASE$ < 1 (rango: 0.9943-1.0074), confirmando que todos mejoran sistem√°ticamente al random walk puro. El $ARIMA(1,1,1)$ + drift obtiene $MASE =$ 0.9943, mejorando al random walk en ~0.6%, lo que en el contexto de series financieras eficientes representa una mejora estad√≠sticamente significativa aunque pr√°cticamente peque√±a (Hyndman & Athanasopoulos, 2021).

La s√≠ntesis de criterios de informaci√≥n y m√©tricas de precisi√≥n conduce a una conclusi√≥n robusta: $ARIMA(1,1,1)$ con drift t√©rmino es el modelo seleccionado. Aunque $ARIMA(3,1,3)$ tiene $RMSE$ ligeramente menor, la ventaja es marginal (0.0033 puntos) mientras que requiere 75% incremento en par√°metros, violando principio de parsimonia. $AICc$ de $ARIMA(1,1,1)$ + drift (4663.94) es indiscutiblemente mejor que competidores, indicando balance superior entre ajuste y complejidad para muestra finita. Desde perspectiva pr√°ctica, el modelo captura estructura de drift (tendencia alcista genuina en $QQQ$ durante per√≠odo) mediante un par√°metro adicional, permitiendo que pron√≥sticos incorporen esta tendencia en lugar de asumir movimiento aleatorio puro (Box & Jenkins, 1976; Brockwell & Davis, 2016).

---

## 4.5 Diagn√≥stico de Residuos

El proceso de diagn√≥stico de residuos constituye la fase final y cr√≠tica de validaci√≥n del modelo ARIMA seleccionado. Un modelo bien especificado debe producir residuos que se comporten como ruido blanco: una secuencia de innovaciones aleatorias con media cero, varianza constante, y ausencia total de autocorrelaci√≥n (Box & Jenkins, 1976; Brockwell & Davis, 2016). La justificaci√≥n te√≥rica es directa: si el modelo $ARIMA$ captura correctamente toda la estructura de dependencia en los datos, entonces lo que permanece (los residuos) debe ser puramente aleatorio. Si se observa estructura residual (autocorrelaci√≥n, heterocedasticidad, no-normalidad), esto indica que la especificaci√≥n del modelo es incompleta: existe informaci√≥n temporal a√∫n no explicada por el $ARIMA(1,1,1)$ + drift seleccionado (Hamilton, 1994; Tsay, 2010).

El diagn√≥stico opera mediante tres enfoques complementarios que examinan aspectos distintos del comportamiento de residuos: (i) an√°lisis visual gr√°fico que revela patrones estructurales, (ii) contrastes formales de hip√≥tesis estad√≠sticas que cuantifican desviaciones de ruido blanco, y (iii) evaluaci√≥n de supuestos distribucionales sobre la forma de los residuos (Hyndman & Athanasopoulos, 2021; Hastie et al., 2009). Juntos, estos enfoques proporcionan evidencia convergente sobre la calidad del ajuste del modelo.

### 4.5.1 An√°lisis Gr√°fico de Residuos

```{r residuos-grafico, echo=TRUE}
residuos <- residuals(ModeloQA)

df_residuos <- data.frame(
  Fecha = index(residuos),
  Residuo = as.numeric(residuos)
)


p1 <- ggplot(df_residuos, aes(x = Fecha, y = Residuo)) +
  geom_line(color = qqq_pal$secondary, linewidth = 0.5) +
  geom_hline(yintercept = 0, linetype = "dashed", 
             color = qqq_pal$primary, linewidth = 0.7) +
  geom_hline(yintercept = c(-2*sd(df_residuos$Residuo), 2*sd(df_residuos$Residuo)), 
             linetype = "dotted", color = qqq_pal$negative, linewidth = 0.5) +
  scale_x_date(date_breaks = "6 months", date_labels = "%b %Y") +
  labs(title = "Residuos del Modelo en el Tiempo",
       subtitle = "Verificaci√≥n de media cero y varianza constante",
       x = NULL,
       y = "Residuo") +
  theme_QQQ() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p1
acf_resid <- acf(residuos, lag.max = 25, plot = FALSE)
df_acf_resid <- data.frame(
  Lag = as.numeric(acf_resid$lag[-1]),
  ACF = as.numeric(acf_resid$acf[-1])
)

n_resid <- length(residuos)
limite_resid <- qnorm(0.975) / sqrt(n_resid)

p2 <- ggplot(df_acf_resid, aes(x = Lag, y = ACF)) +
  geom_hline(yintercept = 0, color = qqq_pal$text_gray, linewidth = 0.5) +
  geom_hline(yintercept = c(-limite_resid, limite_resid), linetype = "dashed", 
             color = qqq_pal$primary, linewidth = 0.6) +
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = -limite_resid, ymax = limite_resid,
           fill = qqq_pal$primary, alpha = 0.1) +
  geom_segment(aes(xend = Lag, yend = 0), color = qqq_pal$secondary, linewidth = 0.7) +
  geom_point(color = qqq_pal$secondary, size = 1.5) +
  scale_x_continuous(breaks = seq(0, 25, 5)) +
  scale_y_continuous(limits = c(-0.15, 0.15)) +
  labs(title = "ACF de Residuos",
       subtitle = "Verificaci√≥n de independencia",
       x = "Rezago (Lag)",
       y = "ACF") +
  theme_QQQ()
p2
p3 <- ggplot(df_residuos, aes(x = Residuo)) +
  geom_histogram(aes(y = after_stat(density)), 
                 bins = 35, fill = qqq_pal$primary, 
                 color = "white", alpha = 0.7) +
  geom_density(color = qqq_pal$secondary, linewidth = 1) +
  stat_function(fun = dnorm, 
                args = list(mean = mean(df_residuos$Residuo), 
                            sd = sd(df_residuos$Residuo)),
                color = qqq_pal$negative, linewidth = 1, linetype = "dashed") +
  labs(title = "Distribuci√≥n de Residuos",
       subtitle = "Verificaci√≥n de normalidad",
       x = "Residuo",
       y = "Densidad",
       caption = "L√≠nea roja punteada: distribuci√≥n normal te√≥rica") +
  theme_QQQ()
p3
```

El primer componente del diagn√≥stico examina la comportamiento temporal de los residuos (panel superior). El gr√°fico exhibe oscilaci√≥n de residuos alrededor de una media pr√≥xima a cero, con bandas de confianza aproximadas ubicadas a ¬±2 desviaciones est√°ndar. La media aritm√©tica de los residuos es pr√°cticamente cero ($E[Œµ‚Çú] ‚âà$ 0.0001), validando que el modelo es aproximadamente insesgado: no subestima ni sobrestima sistem√°ticamente. La varianza aparece aproximadamente constante a lo largo del per√≠odo completo (octubre 2022 - septiembre 2025), sugiriendo homocedasticidad: la volatilidad de errores no cambia dram√°ticamente. Existe, sin embargo, un per√≠odo de mayor volatilidad alrededor de noviembre 2024 donde se observa un residuo extremo (~+50), que coincide con movimientos de volatilidad elevada en mercados tecnol√≥gicos durante esa fecha.

El segundo componente examina la funci√≥n de autocorrelaci√≥n de residuos (panel central). En teor√≠a, si los residuos constituyen ruido blanco verdadero, el $ACF$ debe mostrar pr√°cticamente todas las autocorrelaciones dentro de las bandas de confianza de. Este caso exhibe esta caracter√≠stica: la mayor√≠a de las 25 autocorrelaciones evaluadas caen dentro de bandas (l√≠neas de guiones azules). Se observan algunos picos leves fuera de bandas, pero estos son aislados y de magnitud peque√±a. Para n=746 observaciones, esperamos aproximadamente 5% de autocorrelaciones fuera de bandas por azar puro (5% de 25 lags = 1.25 lags esperados). Observar ~2-3 lags fuera de bandas es consistente con ruido aleatorio, sin indicaci√≥n de autocorrelaci√≥n residual sistem√°tica (Box & Jenkins, 1976; Hyndman & Athanasopoulos, 2021).

El tercer componente examina la distribuci√≥n de residuos (panel inferior). El histograma de densidad (barras verde) muestra forma aproximadamente sim√©trica y unimodal, consistente con una distribuci√≥n normal. La curva de densidad emp√≠rica (l√≠nea azul) se superpone adecuadamente con la curva de distribuci√≥n normal te√≥rica (l√≠nea roja punteada) en la regi√≥n central. Sin embargo, se observa que las colas de la distribuci√≥n emp√≠rica son ligeramente m√°s pesadas que lo predicho por la teor√≠a normal: el histograma muestra m√°s observaciones en regiones extremas (residuos < -15 y > +30) que una normal pura. Este fen√≥meno de "fat tails" (colas gordas) es caracter√≠stico de datos financieros reales, donde eventos extremos ocurren con probabilidad ligeramente mayor que lo predicho por distribuci√≥n normal (Tsay, 2010; Hamilton, 1994). La presencia de colas pesadas no invalida el modelo pero sugiere que intervalos de confianza construidos asumiendo normalidad exacta pueden ser ligeramente conservadores.

### 4.5.2 Q-Q Plot de Normalidad

```{r residuos-qq, echo=TRUE}

residuos_std <- scale(residuals(ModeloQA))
df_qq <- data.frame(residuos = residuos_std)

n <- length(residuos_std)
cuantiles_teoricos <- qnorm(ppoints(n))
cuantiles_observados <- sort(residuos_std)
df_qq_line <- data.frame(x = cuantiles_teoricos, y = cuantiles_observados)

fit <- lm(y ~ x, data = df_qq_line)
df_qq_line$fitted <- predict(fit, df_qq_line)

df_qq_puntos <- data.frame(
  x = cuantiles_teoricos,
  y = cuantiles_observados,
  label = paste0(
    "Cuantil te√≥rico: ", round(cuantiles_teoricos, 3), "<br>",
    "Residuo observado: ", round(cuantiles_observados, 3)
  )
)

p_qq <- ggplot() +
  geom_line(data = df_qq_line, aes(x = x, y = fitted), 
            color = qqq_pal$negative, linewidth = 1.1) +
  geom_point(data = df_qq_puntos, aes(x = x, y = y, text = label),
             color = qqq_pal$primary, size = 2.5, alpha = 0.75) +
  labs(
    title = "Q-Q Plot de Residuos Estandarizados",
    subtitle = "Verificaci√≥n de normalidad del modelo | L√≠nea roja = distribuci√≥n normal te√≥rica",
    x = "Cuantiles Te√≥ricos (Distribuci√≥n Normal Est√°ndar)",
    y = "Cuantiles Observados (Residuos Estandarizados)",
    caption = "‚úì Puntos alineados con la l√≠nea roja indican buenos residuos normales"
  ) +
  theme_QQQ() +
  theme(
    plot.title = element_text(size = 13, face = "bold", color = qqq_pal$primary),
    plot.subtitle = element_text(size = 11, color = qqq_pal$text_gray, margin = margin(b = 8)),
    plot.caption = element_text(size = 9, color = qqq_pal$secondary, face = "italic"),
    panel.background = element_rect(fill = "#f8f9fa", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    axis.line = element_line(color = qqq_pal$text_gray, linewidth = 0.5),
    panel.grid.major = element_line(color = "#e8eef5", linewidth = 0.3),
    panel.grid.minor = element_blank()
  )

plotly::ggplotly(p_qq, tooltip = "text") %>%
  plotly::layout(
    font = list(family = "Arial, sans-serif", size = 11, color = qqq_pal$text_dark),
    plot_bgcolor = "#f8f9fa",
    paper_bgcolor = "white",
    xaxis = list(
      showgrid = TRUE,
      gridwidth = 1,
      gridcolor = "#e8eef5",
      zeroline = FALSE,
      showline = TRUE,
      linewidth = 1,
      linecolor = qqq_pal$text_gray,
      mirror = TRUE
    ),
    yaxis = list(
      showgrid = TRUE,
      gridwidth = 1,
      gridcolor = "#e8eef5",
      zeroline = FALSE,
      showline = TRUE,
      linewidth = 1,
      linecolor = qqq_pal$text_gray,
      mirror = TRUE
    ),
    hovermode = "closest",
    margin = list(l = 60, r = 30, t = 80, b = 60)
  ) %>%
  plotly::config(
    displayModeBar = TRUE,
    displaylogo = FALSE,
    collaborate = FALSE,
    modeBarButtonsToRemove = c("lasso2d", "select2d"),
    toImageButtonOptions = list(
      format = "png",
      filename = "qq_plot_residuos",
      height = 600,
      width = 900,
      scale = 2
    )
  )
```

El $Q-Q$ $plot$ (quantile-quantile plot) proporciona diagn√≥stico visual espec√≠fico de la hip√≥tesis de normalidad mediante comparaci√≥n directa de cuantiles emp√≠ricos versus te√≥ricos. La interpretaci√≥n es intuitiva: si los residuos estandarizados siguen exactamente una distribuci√≥n normal est√°ndar, entonces cada punto debe caer precisamente sobre la l√≠nea roja de referencia. Desviaciones de esta l√≠nea indican desviaciones de normalidad (D'Agostino & Stephens, 1986; Hastie et al., 2009).

En el $Q-Q$ $plot$, se observa alineaci√≥n muy cercana de puntos con la l√≠nea te√≥rica en la regi√≥n central (cuantiles entre -2 y +2, que representan aproximadamente 95% de la distribuci√≥n). Esta es la caracter√≠stica m√°s importante: en esta regi√≥n central donde residen la mayor√≠a de observaciones, la normalidad se cumple aproximadamente. Sin embargo, en las colas (cuantiles te√≥ricos < -2 o > +2), se observa desviaci√≥n sistem√°tica: los cuantiles observados en la cola superior se sit√∫an por encima de la l√≠nea te√≥rica, indicando que residuos extremos positivos son m√°s extremos que lo predicho por una normal. Esto confirma la presencia de "fat tails" ya sugerida por el histograma.

Esta caracter√≠stica de colas pesadas es t√≠pica de retornos de activos financieros y no invalida el modelo $ARIMA$, pero tiene implicaciones para inferencia: intervalos de confianza construidos asumiendo normalidad exacta pueden subesticar probabilidades de eventos extremos, potencialmente subestimando riesgo de cola (tail risk) en pron√≥sticos. Sin embargo, para prop√≥sitos de pron√≥stico de series de tiempo diarias en contexto de an√°lisis acad√©mico, la aproximaci√≥n normal en la regi√≥n central es suficiente (Tsay, 2010; Brockwell & Davis, 2016).

### 4.5.3 Test de Independencia (Ljung-Box)

El test de Ljung-Box proporciona contraste formal de la hip√≥tesis nula de que residuos constituyen ruido blanco versus hip√≥tesis alternativa de que existe autocorrelaci√≥n residual significativa. La estad√≠stica de Ljung-Box, modificaci√≥n del test de Box-Pierce de Ljung & Box (1978), se define como:
$$
Q^* = n(n+2) \sum_{k=1}^{m} \frac{\hat{\rho}_k^{\,2}}{n - k}
$$
donde $n$ es el n√∫mero de residuos, $m$ es el n√∫mero de rezagos evaluados, y $œÅÃÇ‚Çñ $ es la autocorrelaci√≥n muestral en rezago k. Bajo hip√≥tesis nula de independencia, $Q^*$ sigue aproximadamente distribuci√≥n chi-cuadrado con $m$ grados de libertad (Box & Jenkins, 1976; Hamilton, 1994)

```{r residuos-tabla, echo=TRUE}
lb_test <- Box.test(residuals(ModeloQA), lag = 10, type = "Ljung-Box")

tabla_ljung <- data.frame(
  M√©trica = c("Estad√≠stico Ljung-Box", 
              "Grados de Libertad", 
              "P-valor",
              "Conclusi√≥n"),
  Valor = c(
    round(lb_test$statistic, 4),
    lb_test$parameter,
    round(lb_test$p.value, 4),
    ifelse(lb_test$p.value > 0.05, 
           "Residuos son ruido blanco ‚úì", 
           "Posible autocorrelaci√≥n residual")
  )
)

kable(tabla_ljung, 
      caption = "Test de Ljung-Box: Independencia de Residuos",
      align = c("l", "c")) %>%
  kable_styling(bootstrap_options = c("hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(0, background = qqq_pal$primary, color = "white", bold = TRUE) %>%
  row_spec(4, bold = TRUE, 
           background = ifelse(lb_test$p.value > 0.05, "#e8f5e9", "#ffe8e0"),
           color = qqq_pal$text_dark)
```

En nuestro an√°lisis, evaluamos autocorrelaci√≥n en $m=$ 10 rezagos. El estad√≠stico Ljung-Box resultante es $Q^* =$ 10.1399, con 10 grados de libertad. Bajo la distribuci√≥n $œá‚ÇÅ‚ÇÄ¬≤$, el valor cr√≠tico al nivel de significancia 5% es $œá¬≤‚ÇÅ‚ÇÄ,‚ÇÄ.‚ÇÄ‚ÇÖ ‚âà$ 18.31. Como $Q^* =$ 10.1399 < 18.31, no rechazamos la hip√≥tesis nula. Equivalentemente, el $p-valor$ = 0.4283 > 0.05, proporcionando fuerte evidencia de que los residuos no exhiben autocorrelaci√≥n significativa en los primeros 10 rezagos. Este $p-valor$ de 0.43 indica que si verdaderamente los residuos fuesen ruido blanco independiente, observar√≠amos una estad√≠stica de prueba tan extrema o m√°s extrema con probabilidad del 43%‚Äîes decir, el resultado es completamente consistente con independencia (Hyndman & Athanasopoulos, 2021; Tsay, 2010).

La conclusi√≥n del test es suficiente: los residuos del modelo $ARIMA(1,1,1)$ + drift se comportan como ruido blanco independiente. Este resultado, combinado con el an√°lisis gr√°fico que revel√≥ ausencia de estructura temporal, ACF sin picos significativos, y aproximaci√≥n a normalidad en regi√≥n central, proporciona evidencia convergente de que la especificaci√≥n del modelo es adecuada.

El √∫nico hallazgo notable es la presencia de algunos residuos extremos (especialmente el outlier de ~+50 en noviembre 2024), que coincide con per√≠odo de volatilidad elevada en mercados tecnol√≥gicos. Estos son errores de predicci√≥n grandes pero aislados, no sistem√°ticos, consistentes con shocks de mercado ex√≥genos que el modelo $ARIMA$ no puede anticipar (Tsay, 2010; Brockwell & Davis, 2016). En conclusi√≥n, el modelo $ARIMA(1,1,1)$ + drift est√° correctamente especificado y procede a la etapa de pron√≥stico.

---

## 4.6 Pron√≥stico y Evaluaci√≥n

El modelo ARIMA(1,1,1) con drift, habiendo superado todas las pruebas de diagn√≥stico de residuos, procede ahora a la etapa de pron√≥stico: generaci√≥n de predicciones puntuales de precios futuros para el QQQ junto con intervalos de confianza que cuantifican la incertidumbre inherente. La pr√°ctica de pron√≥stico en series de tiempo requiere distinci√≥n cr√≠tica entre dos enfoques complementarios: pron√≥stico ex-ante (predicci√≥n de valores verdaderamente desconocidos en horizonte futuro) versus pron√≥stico ex-post (predicci√≥n de valores conocidos pero retenidos como conjunto de prueba para evaluaci√≥n). El an√°lisis que sigue utiliza ambos enfoques: primero se generan pron√≥sticos ex-post sobre el conjunto de prueba (octubre 2025, 10 observaciones retenidas) para evaluar precisi√≥n del modelo, y luego se presentan pron√≥sticos ex-ante sobre horizonte futuro inmediato.

```{r pronostico-generacion, echo=TRUE}
pronostico <- forecast(ModeloQA, h = 10, level = 95)

ultima_fecha <- as.Date(index(Entrenamiento)[length(Entrenamiento)])

fechas_pronostico <- c()
fecha_actual <- ultima_fecha
dias_agregados <- 0

while(dias_agregados < 10) {
  fecha_actual <- fecha_actual + 1
  if (!(weekdays(fecha_actual) %in% c("s√°bado", "domingo", "Saturday", "Sunday"))) {
    fechas_pronostico <- c(fechas_pronostico, fecha_actual)
    dias_agregados <- dias_agregados + 1
  }
}

fechas_pronostico <- as.Date(fechas_pronostico, origin = "1970-01-01")
```

### 4.6.1 Tabla de Pron√≥sticos

```{r tabla-pronosticos, echo=TRUE}
tabla_pronostico <- data.frame(
  D√≠a = 1:10,
  Fecha = as.character(fechas_pronostico),
  Pron√≥stico = round(as.numeric(pronostico$mean), 2),
  `L√≠mite Inferior` = round(as.numeric(pronostico$lower), 2),
  `L√≠mite Superior` = round(as.numeric(pronostico$upper), 2),
  `Amplitud IC` = round(as.numeric(pronostico$upper) - as.numeric(pronostico$lower), 2)
)

kable(tabla_pronostico,
      caption = "Pron√≥sticos del Modelo ARIMA(1,1,1) con Drift - Intervalo de Confianza al 95%",
      align = c("c", "c", "c", "c", "c", "c"),
      col.names = c("D√≠a", "Fecha", "Pron√≥stico (USD)", "L√≠m. Inferior", "L√≠m. Superior", "Amplitud IC")) %>%
  kable_styling(bootstrap_options = c("hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(0, background = qqq_pal$primary, color = "white", bold = TRUE) %>%
  column_spec(1, bold = TRUE, color = qqq_pal$primary) %>%
  column_spec(3, bold = TRUE, color = qqq_pal$primary, background = "#f0f9ff") %>%
  column_spec(4, color = qqq_pal$negative) %>%
  column_spec(5, color = qqq_pal$positive) %>%
  column_spec(6, color = "#666666") %>%
  footnote(general = "IC = Intervalo de Confianza. La amplitud del intervalo aumenta con el horizonte de pron√≥stico.",
           general_title = "Nota: ")
```

Los pron√≥sticos puntuales generados por el modelo $ARIMA(1,1,1)$ + drift exhiben un patr√≥n revelador: los precios predichos para los pr√≥ximos 10 d√≠as h√°biles (01-octubre a 14-octubre 2025) se ubican en el rango 600.71 a 604.76 USD, con trayectoria que muestra incremento sostenido pero moderado (pendiente del drift positiva pero peque√±a). El primer pron√≥stico (d√≠a 1, 01-octubre) es 600.71, comparado con el √∫ltimo precio observado al 30-septiembre de aproximadamente 599.58. Este incremento inicial de ~$1.13 refleja la estimaci√≥n de drift del modelo: una tendencia alcista promedio de Œº ‚âà 0.4-0.5 d√≥lares por d√≠a (aproximadamente 0.07% diario o 1.4% anual), capturable mediante el t√©rmino constante en la ecuaci√≥n de diferencias (Brockwell & Davis, 2016; Box & Jenkins, 1976).

La caracter√≠stica m√°s notable de los pron√≥sticos es la amplitud expansiva de los intervalos de confianza: el IC 95% en el d√≠a 1 tiene amplitud de apenas 21.54 (aproximadamente ¬±10.77 alrededor del pron√≥stico puntual), pero se expande a 66.01 en el d√≠a 10 (aproximadamente ¬±33). Esta expansi√≥n obedece a la naturaleza de la propagaci√≥n de incertidumbre en pron√≥sticos: conforme aumenta el horizonte h, la varianza del pron√≥stico $Œµ_h$ bajo un $ARIMA(1,1,1)$ crece aproximadamente como $œÉ¬≤¬∑h$ (para ARIMA no estacionario con d=1), donde $œÉ¬≤$ es la varianza de innovaciones. As√≠, mientras el modelo predice una trayectoria promedio suavemente alcista, reconoce que verdadero precio futuro puede desviarse de esta trayectoria de manera creciente, reflejando la caracter√≠stica fundamental de mercados financieros eficientes: la predictibilidad diminuye exponencialmente con horizonte (Hamilton, 1994; Malkiel, 1973).

### 4.6.2 Gr√°fico: Pron√≥stico con Intervalo de Confianza

```{r grafico-pronostico, echo=TRUE, fig.height=6.5}
n_historico <- 100
datos_hist <- tail(Entrenamiento, n_historico)

df_historico <- data.frame(
  Fecha = as.Date(index(datos_hist)),
  Precio = as.numeric(datos_hist),
  Tipo = "Hist√≥rico"
)

ultima_fecha <- as.Date(index(Entrenamiento)[length(Entrenamiento)])
fechas_forecast <- ultima_fecha + 1:10

df_pronostico <- data.frame(
  Fecha = fechas_forecast,
  Precio = as.numeric(pronostico$mean),
  Lower = as.numeric(pronostico$lower),
  Upper = as.numeric(pronostico$upper)
)

punto_conexion <- data.frame(
  Fecha = ultima_fecha,
  Precio = as.numeric(tail(datos_hist, 1)),
  Lower = as.numeric(tail(datos_hist, 1)),
  Upper = as.numeric(tail(datos_hist, 1))
)

df_pronostico_completo <- bind_rows(punto_conexion, df_pronostico)

ggplot() +
  geom_ribbon(data = df_pronostico_completo,
              aes(x = Fecha, ymin = Lower, ymax = Upper),
              fill = qqq_pal$secondary, alpha = 0.2) +
  geom_line(data = df_historico,
            aes(x = Fecha, y = Precio),
            color = qqq_pal$primary, linewidth = 0.7) +
  geom_line(data = df_pronostico_completo,
            aes(x = Fecha, y = Precio),
            color = qqq_pal$secondary, linewidth = 0.8) +
  geom_point(data = df_pronostico %>% filter(Fecha == max(Fecha)),
             aes(x = Fecha, y = Precio),
             color = qqq_pal$secondary, size = 2.5) +
  geom_point(data = punto_conexion,
             aes(x = Fecha, y = Precio),
             color = qqq_pal$primary, size = 2.5) +
  geom_vline(xintercept = ultima_fecha, 
             linetype = "dashed", color = qqq_pal$negative, linewidth = 0.5) +
  annotate("label",
           x = min(df_historico$Fecha) + 15,
           y = max(df_historico$Precio, df_pronostico$Upper) * 0.99,
           label = "Entrenamiento",
           fill = qqq_pal$primary, color = "white",
           fontface = "bold", size = 3, label.padding = unit(0.3, "lines")) +
  annotate("label",
           x = max(df_pronostico$Fecha) - 3,
           y = max(df_pronostico$Upper) * 1.01,
           label = "Pron√≥stico",
           fill = qqq_pal$secondary, color = "white",
           fontface = "bold", size = 3, label.padding = unit(0.3, "lines")) +
  scale_x_date(date_breaks = "3 weeks", date_labels = "%d %b",
               expand = expansion(mult = c(0.02, 0.08))) +
  scale_y_continuous(labels = scales::dollar_format(),
                     expand = expansion(mult = c(0.02, 0.05))) +
  labs(title = "Pron√≥stico ARIMA(1,1,1) con Drift",
       subtitle = "QQQ (Nasdaq-100 ETF) | √öltimos 100 d√≠as + 10 d√≠as de pron√≥stico | IC 95%",
       x = NULL,
       y = "Precio de Cierre (USD)",
       caption = "L√≠nea verde: Datos hist√≥ricos | L√≠nea cian: Pron√≥stico | √Årea sombreada: Intervalo de confianza 95%") +
  theme_QQQ() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

La visualizaci√≥n gr√°fica del pron√≥stico proporciona perspectiva intuitiva sobre la trayectoria predicha y su incertidumbre asociada. Los √∫ltimos 100 d√≠as hist√≥ricos (aproximadamente 5 meses de actividad de mercado) muestran patr√≥n de volatilidad moderada alrededor de tendencia ascendente: el $QQQ$ se movi√≥ desde aproximadamente 515 en mayo 2025 hasta 599.58 en septiembre 2025, representando ganancia de ~16.4% durante el per√≠odo. Esta trayectoria alcista justifica la estimaci√≥n del drift positivo: el modelo reconoce que durante el per√≠odo de entrenamiento (octubre 2022 - septiembre 2025) existi√≥ movimiento sistem√°tico al alza.

El pron√≥stico de 10 d√≠as contin√∫a esta tendencia pero de manera conservadora: en lugar de proyectar aceleraci√≥n, predice continuaci√≥n lineal suave con pendiente determinada por el drift estimado. La banda de confianza (√°rea sombreada azul claro) inicia estrecha alrededor del pron√≥stico puntual y se expande progresivamente, reflejando incertidumbre creciente. Por horizonte h=10 d√≠as, el intervalo 95% abarca aproximadamente 571.75 a 637.76, un rango de 66 o ¬±5.5% alrededor del pron√≥stico central. Esta amplitud es consistente con volatilidad hist√≥rica del $QQQ$ (~1-1.5% diaria en desviaci√≥n est√°ndar), sugeriendo que el modelo calibra apropiadamente su incertidumbre (Tsay, 2010).

### 4.6.3 Evaluaci√≥n Comparativa: Predicho vs Real

```{r predicho-vs-real, echo=TRUE, fig.height=6}
reales <- head(as.numeric(Prueba), 10)
predichos <- as.numeric(pronostico$mean)
fechas_prueba <- head(as.Date(index(Prueba)), 10)

df_evaluacion <- data.frame(
  Dia = 1:10,
  Fecha = fechas_prueba,
  Real = reales,
  Predicho = round(predichos, 2),
  Error = round(reales - predichos, 2),
  Error_Abs = round(abs(reales - predichos), 2),
  Error_Pct = round((reales - predichos) / reales * 100, 2)
)

df_largo <- df_evaluacion %>%
  select(Dia, Fecha, Real, Predicho) %>%
  pivot_longer(cols = c(Real, Predicho),
               names_to = "Tipo",
               values_to = "Precio")

ggplot(df_largo, aes(x = Dia, y = Precio, color = Tipo, shape = Tipo)) +
  geom_line(linewidth = 0.8) +
  geom_point(size = 3) +
  geom_ribbon(data = df_evaluacion,
              aes(x = Dia, y = Predicho,
                  ymin = as.numeric(pronostico$lower),
                  ymax = as.numeric(pronostico$upper)),
              fill = qqq_pal$secondary, alpha = 0.15,
              inherit.aes = FALSE) +
  scale_color_manual(values = c("Real" = qqq_pal$primary, 
                                "Predicho" = qqq_pal$secondary),
                     labels = c("Predicho" = "Pron√≥stico", "Real" = "Valor Real")) +
  scale_shape_manual(values = c("Real" = 16, "Predicho" = 17),
                     labels = c("Predicho" = "Pron√≥stico", "Real" = "Valor Real")) +
  scale_x_continuous(breaks = 1:10, labels = paste0("t+", 1:10)) +
  scale_y_continuous(labels = scales::dollar_format()) +
  labs(title = "Evaluaci√≥n del Pron√≥stico: Valores Reales vs Predichos",
       subtitle = "QQQ (Nasdaq-100 ETF) | Primeros 10 d√≠as del conjunto de prueba",
       x = "Horizonte de Pron√≥stico",
       y = "Precio de Cierre (USD)",
       color = NULL,
       shape = NULL,
       caption = "√Årea sombreada: Intervalo de confianza 95%") +
  theme_QQQ() +
  theme(legend.position = "top")
```

La evaluaci√≥n comparativa de pron√≥sticos ex-post (sobre el conjunto de prueba retenido) proporciona evidencia directa de capacidad predictiva del modelo en horizonte corto. Los primeros 10 d√≠as observados de octubre 2025 revelan patr√≥n interesante: los valores reales exhiben volatilidad que oscila alrededor de la l√≠nea de pron√≥stico, sin divergencia sistem√°tica consistente. Espec√≠ficamente, durante d√≠as 1-7, los valores reales tienden ligeramente por encima del pron√≥stico (el QQQ alcanz√≥ m√°ximos de 611.44 el d√≠a 6), sugiriendo que el drift estimado fue ligeramente conservador. Sin embargo, durante d√≠as 8-10, los valores reales caen por debajo del pron√≥stico (m√≠nimo de 589.50 el d√≠a 8), capturando volatilidad ex√≥gena que el modelo $ARIMA$ no puede anticipar.

Este patr√≥n de desviaciones relativamente peque√±as y no-sistem√°ticas es exactamente lo esperado bajo la hip√≥tesis de mercado eficiente: el modelo captura la tendencia principal (drift) pero no puede predecir shocks ex√≥genos. N√≥tese que todos los 10 valores reales caen dentro del intervalo de confianza 95%, lo cual validar√≠a calibraci√≥n correcta de la incertidumbre. Esto es evidencia emp√≠rica de que el modelo no solo captura direcci√≥n (tendencia alcista), sino tambi√©n magnitud apropiada de incertidumbre (amplitud del intervalo).

### 4.6.4 Tabla de Errores por Observaci√≥n

```{r tabla-errores, echo=TRUE}
tabla_errores <- df_evaluacion %>%
  select(Dia, Fecha, Real, Predicho, Error, Error_Pct) %>%
  mutate(
    Fecha = as.character(Fecha),
    Real = paste0("$", round(Real, 2)),
    Predicho = paste0("$", round(Predicho, 2)),
    Error = round(Error, 2),
    Error_Pct = paste0(round(Error_Pct, 2), "%")
  )

kable(tabla_errores,
      caption = "Evaluaci√≥n del Pron√≥stico: Errores por Observaci√≥n",
      align = c("c", "c", "c", "c", "c", "c"),
      col.names = c("D√≠a", "Fecha", "Valor Real", "Pron√≥stico", "Error (USD)", "Error (%)")) %>%
  kable_styling(bootstrap_options = c("hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(0, background = qqq_pal$primary, color = "white", bold = TRUE) %>%
  column_spec(1, bold = TRUE, color = qqq_pal$primary) %>%
  column_spec(3, color = qqq_pal$primary, bold = TRUE) %>%
  column_spec(4, color = qqq_pal$secondary, bold = TRUE) %>%
  column_spec(5, bold = TRUE) %>%
  column_spec(6, bold = TRUE) %>%
  footnote(general = "Error positivo: el modelo subestim√≥ (valor real > pron√≥stico). Error negativo: el modelo sobreestim√≥.",
           general_title = "Nota: ")
```

El an√°lisis granular de errores por observaci√≥n individual revela distribuci√≥n asim√©trica pero no-sistem√°tica. Los primeros tres d√≠as (1-3 octubre) exhiben errores positivos peque√±os (2.54, 4.50, 1.57), indicando subestimaci√≥n leve pero consistente‚Äîel modelo predijo conservadoramente durante esta fase. Los d√≠as 4-7 exhiben variaci√≥n: d√≠a 4 tiene error mayor (+5.60 el 06-octubre, coincidiendo con m√°ximo local), d√≠as 5-6 muestran errores moderados, d√≠a 7 retorna a error moderado (+$7.29).

El quiebre ocurre en d√≠a 8 (10-octubre): error de -14.37, representando subestimaci√≥n grande del valor real de 589.50 contra pron√≥stico de 603.87. Este es √∫nico error negativo significativo en la muestra, coincidiendo con ca√≠da de volatilidad en el mercado esa fecha. Sin embargo, n√≥tese que incluso este error de -14.37 permanece dentro del intervalo de confianza: el l√≠mite inferior para d√≠a 8 es 574.34, y 589.50 > 574.34. Los d√≠as 9-10 muestran peque√±os errores negativos (-2.29 y -$6.76), regresando a patr√≥n de desviaciones moderadas.

Lo notable es la simetr√≠a aproximada de errores: errores positivos en d√≠as 1-7 son aproximadamente balanceados por errores negativos en d√≠as 8-10. Esto indica que el modelo no tiene sesgo sistem√°tico direccional‚Äîes aproximadamente insesgado aunque comete errores individuales t√≠picos de predicci√≥n financiera (Tsay, 2010; Hamilton, 1994).

### 4.6.5 M√©tricas Finales de Evaluaci√≥n

```{r metricas-finales, echo=TRUE}
MAE <- mean(abs(df_evaluacion$Error))
RMSE <- sqrt(mean(df_evaluacion$Error^2))
MAPE <- mean(abs(df_evaluacion$Error_Pct))
ME <- mean(df_evaluacion$Error)

dentro_IC <- sum(reales >= as.numeric(pronostico$lower) & 
                   reales <= as.numeric(pronostico$upper))
pct_dentro_IC <- dentro_IC / 10 * 100

tabla_metricas <- data.frame(
  M√©trica = c("Error Medio (ME)",
              "Error Absoluto Medio (MAE)",
              "Ra√≠z del Error Cuadr√°tico Medio (RMSE)",
              "Error Porcentual Absoluto Medio (MAPE)",
              "Observaciones dentro del IC 95%"),
  Valor = c(paste0("$", round(ME, 2)),
            paste0("$", round(MAE, 2)),
            paste0("$", round(RMSE, 2)),
            paste0(round(MAPE, 2), "%"),
            paste0(dentro_IC, " de 10 (", pct_dentro_IC, "%)")),
  Interpretaci√≥n = c(
    ifelse(abs(ME) < 1, "Sin sesgo sistem√°tico ‚úì", 
           ifelse(ME > 0, "Modelo subestima", "Modelo sobreestima")),
    "Error promedio en USD",
    "Penaliza errores grandes",
    "Error relativo al precio",
    ifelse(pct_dentro_IC >= 80, "Intervalos bien calibrados ‚úì", 
           "Intervalos pueden estar mal calibrados")
  )
)

kable(tabla_metricas,
      caption = "M√©tricas de Evaluaci√≥n del Pron√≥stico - Datos de Prueba",
      align = c("l", "c", "l")) %>%
  kable_styling(bootstrap_options = c("hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(0, background = qqq_pal$primary, color = "white", bold = TRUE) %>%
  column_spec(1, bold = TRUE, color = qqq_pal$primary) %>%
  column_spec(2, bold = TRUE) %>%
  row_spec(5, background = "#e8f5e9", color = qqq_pal$text_dark, bold = TRUE)
```

Las m√©tricas de evaluaci√≥n agregadas sintetizan el desempe√±o del modelo $ARIMA(1,1,1)$ + drift sobre el horizonte de 10 d√≠as de prueba. El Error Medio (ME) = 0.85 es notablemente peque√±o, pr√°cticamente cero en t√©rminos pr√°cticos (0.14% del precio promedio observado de ~604). Esto valida que el modelo no contiene sesgo direccional sistem√°tico: no subestima ni sobrestima persistentemente. La acumulaci√≥n de errores positivos y negativos se cancela, produciendo $ME$ cercano a cero‚Äîcaracter√≠stica fundamental de un modelo bien especificado.

El Error Absoluto Medio (MAE) = 5.54 cuantifica la magnitud promedio de desviaci√≥n: en promedio, las predicciones erraron por aproximadamente 5.54, o 0.92% del precio. Para un ETF tecnol√≥gico vol√°til como el $QQQ$, este nivel de error es peque√±o aunque no negligible. En contexto de inversi√≥n, error de ~5.54 en predicci√≥n de precio de 604 representa precisi√≥n suficiente para identificar direcci√≥n general pero insuficiente para timing exacto. La Ra√≠z del Error Cuadr√°tico Medio (RMSE) = 6.68 es ligeramente superior a $MAE$ porque penaliza desviaciones grandes: el error m√°ximo observado (-14.37 en d√≠a 8) elevado al cuadrado domina el c√°lculo de $RMSE$.

El Error Porcentual Absoluto Medio (MAPE) = 0.92% expresa error en t√©rminos relativos: en promedio, predicciones erraron por menos de 1% del valor real. Este es un est√°ndar de desempe√±o excelente para pron√≥stico de precios de activos financieros, donde volatilidad diaria t√≠pica es 1-2% (Hyndman & Athanasopoulos, 2021). La m√©trica m√°s reveladora es "Observaciones dentro del IC 95%" = 10 de 10 (100%). Esta perfecta cobertura indica que el intervalo de confianza fue exactamente bien calibrado: todos los valores reales cayeron dentro de las bandas predichas, ni m√°s ni menos que lo esperado te√≥ricamente. Si el modelo fuese mal especificado, se esperar√≠a que algunos valores reales cayesen fuera del intervalo; el hecho de que todos caigan dentro valida la calibraci√≥n correcta de la incertidumbre (Hyndman & Koehler, 2006).

# 9. Conclusiones

## 9.1 Hallazgos Principales

[**PLACEHOLDER:** Resumen de hallazgos principales del an√°lisis ARIMA]

## 9.2 Implicaciones Pr√°cticas

[**PLACEHOLDER:** Implicaciones de los pron√≥sticos para inversionistas y analistas de mercado]

## 9.3 Limitaciones del An√°lisis

[**PLACEHOLDER:** Limitaciones del modelo y aspectos no capturados]

## 9.4 Recomendaciones Futuras

[**PLACEHOLDER:** Sugerencias para mejoras y extensiones del an√°lisis]

---
# Bibliograf√≠a

Box, G. E. P., & Jenkins, G. M. (1976). *Time series analysis: Forecasting and control* (2nd ed.). Holden-Day.

Brockwell, P. J., & Davis, R. A. (2016). *Introduction to time series and forecasting* (3rd ed.). Springer.

Chatfield, C. (2000). *Time-series forecasting*. Chapman and Hall/CRC.

Dickey, D. A., & Fuller, W. A. (1979). Distribution of the estimators for autoregressive time series with a unit root. *Journal of the American Statistical Association*, 74(366), 427‚Äì431.

Hamilton, J. D. (1994). *Time series analysis*. Princeton University Press.

Hyndman, R. J., & Athanasopoulos, G. (2021). *Forecasting: principles and practice* (3rd ed.). OTexts. https://otexts.com/fpp3/

Jarque, C. M., & Bera, A. K. (1987). A test for normality of observations and regression residuals. *International Statistical Review*, 55(2), 163‚Äì172.

Ljung, G. M., & Box, G. E. P. (1978). On a measure of lack of fit in time series models. *Biometrika*, 65(2), 297‚Äì303.

Tsay, R. S. (2010). *Analysis of financial time series* (3rd ed.). John Wiley & Sons.

```{=html}
<div style="
  margin-top: 80px;
  padding: 40px;
  background: linear-gradient(135deg, rgba(124, 58, 237, 0.15), rgba(6, 182, 212, 0.08));
  border: 2px solid rgba(124, 58, 237, 0.4);
  border-radius: 15px;
  border-top: 3px solid rgba(132, 204, 22, 0.8);
  text-align: center;
  color: #e0e6ed;
  font-size: 0.95em;
  line-height: 1.8;
  box-shadow: 0 8px 30px rgba(124, 58, 237, 0.2);
">
  <div style="margin-bottom: 20px; background: linear-gradient(135deg, #7c3aed, #06b6d4); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: 700; font-size: 1.1em;">
    ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  </div>
  
  <strong style="background: linear-gradient(135deg, #7c3aed, #06b6d4); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">ASIGNATURA:</strong> Gesti√≥n de Datos<br>
  <strong style="background: linear-gradient(135deg, #7c3aed, #06b6d4); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">PROFESOR:</strong> Orlando Joaqui-Barandica<br>
  <strong style="background: linear-gradient(135deg, #7c3aed, #06b6d4); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">UNIVERSIDAD:</strong> Universidad del Valle<br>
  <strong style="background: linear-gradient(135deg, #7c3aed, #06b6d4); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">FACULTAD:</strong> Facultad de Ingenier√≠a<br>
  <strong style="background: linear-gradient(135deg, #7c3aed, #06b6d4); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">PROGRAMA:</strong> Ingenier√≠a Industrial<br>
  
  <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(124, 58, 237, 0.3);">
    <strong style="background: linear-gradient(135deg, #06b6d4, #84cc16); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">ESTUDIANTE:</strong> Camilo<br>
    <strong style="background: linear-gradient(135deg, #06b6d4, #84cc16); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">FECHA ENTREGA:</strong> <span id="fecha-entrega"></span><br>
    <strong style="background: linear-gradient(135deg, #06b6d4, #84cc16); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">VERSI√ìN:</strong> 1.0<br>
  </div>
  
  <div style="margin-top: 20px; color: #94a3b8; font-size: 0.9em;">
    <em>Documento generado con R Markdown | Tema: Series de Tiempo y Pron√≥sticos ARIMA</em>
  </div>
  
  <div style="margin-top: 15px; background: linear-gradient(135deg, #7c3aed, #06b6d4); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: 700;">
    ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  </div>
</div>
```
